<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ydPro-G.github.io/</id>
    <title>ydPro Blog</title>
    <updated>2020-03-17T04:19:09.630Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ydPro-G.github.io/"/>
    <link rel="self" href="https://ydPro-G.github.io/atom.xml"/>
    <subtitle>Life &amp; Work</subtitle>
    <logo>https://ydPro-G.github.io/images/avatar.png</logo>
    <icon>https://ydPro-G.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ydPro Blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux_数据提取]]></title>
        <id>https://ydPro-G.github.io/post/linux_-shu-ju-ti-qu/</id>
        <link href="https://ydPro-G.github.io/post/linux_-shu-ju-ti-qu/">
        </link>
        <updated>2020-03-17T04:18:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前提">前提</h1>
<p>有时候我们需要从文件里提取数据，当然也可能是老板甩过来一个文件让你把里面的电话和邮箱全部提取，这时候一条一条的复制粘贴总是太麻烦，这个时候我们就需要利用一些命令和正则表达式在linux系统中自动提取出来。</p>
<hr>
<h1 id="目标">目标</h1>
<p>1.提取<code>data2</code>文件中的数字开头的行，并把他们写入<code>/home/root/num</code>中。<br>
2.提取<code>data2</code>文件中的邮箱，并把他们写入<code>/home/root/mail</code>中。<br>
补充：<code>data2</code>文件目录<code>/home/root/data2</code><br>
<code>data2</code>包含内容<br>
<img src="https://img-blog.csdnimg.cn/20191225111026739.png" alt="" loading="lazy"></p>
<h1 id="实例">实例</h1>
<pre><code class="language-cpp">1.提取数字开头的行，并写入/home/root/num中
grep '^[0-9]' /home/root/data2 &gt; /home/root/num    # ^：匹配输入字符串的开始位置
                                                   # [0-9]：匹配所有数字
                                                   # &gt;：重定向
                                   
2.提取文件中的所有邮箱，并写入/home/root/amil中
grep -E '*@*\.com' /home/root/data2 &gt; /home/root/mail    # -E:扩展正则表达式
                                                         
</code></pre>
<h5 id="扩展正则表达式与正则表达式的不同它们之间的区别仅仅是元字符不同">扩展正则表达式与正则表达式的不同：它们之间的区别仅仅是元字符不同。</h5>
<h5 id="基础正则表达式bre元字符">基础正则表达式（BRE）元字符：<code>^</code>,<code>$</code>,<code>.</code>,<code>[]</code>,<code>*</code>。</h5>
<h5 id="扩展正则表达式ere元字符添加了">扩展正则表达式（ERE）元字符:添加了<code>+</code>，<code>?</code>,<code>|</code>,<code>()</code>,<code>{}</code>。</h5>
<p>元字符作用详细信息：<a href="https://www.cnblogs.com/linyfeng/p/7353693.html">参考网址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_正则表达式]]></title>
        <id>https://ydPro-G.github.io/post/linux_-zheng-ze-biao-da-shi/</id>
        <link href="https://ydPro-G.github.io/post/linux_-zheng-ze-biao-da-shi/">
        </link>
        <updated>2020-03-17T04:17:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目标">目标</h1>
<p>1.掌握基本命令：sed ,grep ,awk的用法<br>
2.掌握正则表达式符号和语法</p>
<h1 id="学习目录">学习目录</h1>
<p>1.什么是正则表达式？<br>
2.正则表达式的基本语法<br>
3.grep命令<br>
4.sed流编辑器<br>
5.awk文本处理语言</p>
<hr>
<h2 id="1什么是正则表达式">1.什么是正则表达式？</h2>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。正则表达式就是记录文本规则的代码。<br>
下面通过<code>grep，sed和awk</code>命令来实际演示正则表达式如何使用。<br>
<a href="https://www.jb51.net/tools/zhengze.html">参考网址</a></p>
<hr>
<h2 id="2正则表达式的基本语法">2.正则表达式的基本语法</h2>
<p>一个正则表达式通常被称为一个pattern，为用来描述或者匹配一系列符合某个句法规则的字符串。</p>
<h3 id="选择">选择</h3>
<p><code>|</code>:表示选择。<br>
实例： <code>boy|girl</code>可以匹配boy或girl。</p>
<h3 id="限定数量">限定数量</h3>
<p><code>+</code>:表示<code>+</code>号前面的字符必须出现至少一次或多次。<br>
实例：<code>&quot;goo+gle&quot;</code>可以匹配出<code>gooogle，goooogle</code>。</p>
<p><code>?</code>;表示<code>?</code>前面的字符最多出现一次（0次或1次）。<br>
实例：<code>&quot;colou？r&quot;</code>可以匹配<code>color，colour</code>。</p>
<p><code>*</code>:表示<code>*</code>前面的字符可以不出现也可以出现一次或多次。<br>
实例：<code>&quot;0*42&quot;</code>可以匹配<code>42,042,0042,00042</code>。</p>
<h3 id="范围和优先级">范围和优先级</h3>
<p><code>()</code>圆括号可以用来定义模式字符串的范围和优先级。</p>
<h3 id="语法">语法</h3>
<p><code>\</code>:<strong>将下一个字符标记为一个特殊字符或一个原义字符。</strong><br>
<code>^</code>:匹配<strong>输入字符串开始的位置。</strong><br>
<code>$</code>:匹配<strong>输入字符串的结束位置。</strong><br>
<code>{n}</code>:n是一个非负整数<strong>匹配确定的n次。</strong><br>
实例：<code>&quot;o{2}&quot;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code>。<br>
<code>{n,}</code>:n是一个非负整数，<strong>至少匹配n次。</strong><br>
实例：<code>&quot;o{2,}&quot;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>fooooood</code>中的所有<code>o</code>。<code>o{1,}</code>等价于<code>o+</code>。<code>o{0,}等价于o*</code>.<br>
<code>{n,m}</code>:m和n均为非负整数，其中n&lt;=m。<strong>最少匹配<code>n</code>次且最多匹配<code>m</code>次。</strong><br>
<code>*</code>:匹配前面的子表达式零次或多次。例如，<code>zo*</code>能匹配<code>“z”、“zo”以及“zoo”</code>。*等价于<code>{0,}</code><br>
<code>+</code>:匹配前面的子表达式一次或多次。<br>
<code>?</code>:匹配前面的子表达式零次或一次。<br>
<code>.</code>:匹配除<code>\n</code>之外的任何单个字符。<br>
<code>（pattern）</code>:匹配pattern并获取这一匹配的子字符串。<br>
<code>x|y</code>:匹配x或y。<br>
<code>[xyz]</code>:字符集合。匹配所包含的任一字符。<br>
<code>[^xyz]</code>:排除型字符集合。匹配未列出的任意字符。<br>
<code>[a-z]</code>:字符范围。匹配指定范围内的任意字符。<br>
<code>[^a-z]</code>:排除型字符范围。匹配任何不在指定范围内的任意字符。<br>
【思维导图】</p>
<hr>
<h2 id="3grep命令">3.grep命令</h2>
<p>grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。</p>
<h4 id="grep支持的三种正则表达式引擎">grep支持的三种正则表达式引擎</h4>
<p>1.<code>-E</code>:POSIX扩展正则表达式 ERE<br>
2.<code>-G</code>：POSIX基本正则表达式 BRE<br>
3.<code>-p</code>：perl正则表达式 PCRE<br>
<a href="https://wangchujiang.com/linux-command/c/grep.html">grep命令参考网址</a></p>
<h4 id="使用正则表达式bre">使用正则表达式BRE</h4>
<p>实例：</p>
<pre><code class="language-cpp">位置：
grep '^a' /etc/passwd  #查找/etc/passwd文件中以a开头的行

数量：
echo zero\nzo\nzoo | grep 'z.*o'   #匹配以z开头以o结尾的所有字符串。
echo zero\nzo\nzoo | grep 'z.o'    #匹配以z开头的以o结尾中间包含任一字符的字符串。
echo zero\nzo\nzoo | grep 'zo*'    #匹配以z开头以任意多个o结尾的字符串

选择：
nl /etc/passwd | grep '[a-z]'   #匹配/etc/passwd中所有的小写字母
nl /etc/passwd | grep '[0-9]'   #匹配/etc/passwd所有数字
nl /etc/passwd | grep '[[:digit:]]'   #匹配/etc/passwd所有数字
nl /etc/passwd | grep '[[:lower:]]'   #匹配/etc/passwd所有小写字母
nl /etc/passwd | grep '[[:upper:]]'   #匹配/etc/passwd所有大写字母
nl /etc/passwd | grep '[[:alnum:]]'   #匹配/etc/passwd所有字母和数字
nl /etc/passwd | grep '[[:alpha:]]'   #匹配/etc/passwd所有字母

排除字符
echo 'geek\ngood' | grep '[^o]'    #当^放入[]代表排除字符，o不显示
</code></pre>
<h4 id="使用扩展正则表达式ere">使用扩展正则表达式ERE</h4>
<p>要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。<br>
实例：</p>
<pre><code class="language-cpp">数量：
nl /etc/passwd | grep -E 'zo{1}'    #只匹配zo
echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'    #匹配以zo开头的所有单词  

选择：
echo 'www.baidu.com\nwww.google.com\nwww.bing.com' | grep -E 'www\.(google|bing)\.com'   
#匹配www.google.com和www.bing.com
echo 'www.baidu.com\nwww.google.com\nwww.bing.com' | grep -Ev 'www\.baidu\.com'
#匹配不包含www.baidu.com的内容
PS：.号有特殊含义，需要\转义符来转义
</code></pre>
<hr>
<h2 id="4sed流编辑器">4.sed流编辑器</h2>
<p>功能强大的流式文本编辑器。<br>
sed 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<h3 id="sed基本格式">sed基本格式</h3>
<p><code>sed [参数]... [执行命令][输入文件]...</code><br>
<a href="https://wangchujiang.com/linux-command/c/sed.html">sed命令参考网址</a></p>
<h4 id="sed动作指令">sed动作指令</h4>
<p><code>s</code>:行内替换<br>
<code>c</code>:整行替换<br>
<code>a</code>:插到指定行的后面<br>
<code>i</code>:插到指定行的前面<br>
<code>p</code>:打印指定行，通常与<code>-n</code>参数配合使用<br>
<code>d</code>:删除指定行<br>
实例：</p>
<pre><code class="language-cpp">打印指定行（p）:
nl passwd（文件） | sed -n '2,5p'    #打印2-5行
nl passwd（文件） | sed -n '1~2p'    #打印奇数行

行内替换（s）：
sed -n 's/zsh/hehe/gp' passwd(文件)
#将输入文本中zsh全局替换为hehe，并且只打印替换的那一行

删除某行（d）:
sed -i '30d' passwd(文件)    #删除30行
</code></pre>
<hr>
<h2 id="5awk文本处理语言">5.awk文本处理语言</h2>
<p>文本和数据进行处理的编程语言。<br>
awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。<br>
操作基于<code>pattern {action}</code>完成。<br>
实例：</p>
<pre><code class="language-cpp">准备：
vim test    #使用vim新建一个文本文档
I like Linux 
www.github.com    #输入以上内容

将文本内容打印到终端
1.
awk '{
print
}' test
2.
awk '{print}' test    #可以写多行也可以写一行

将test第一行的每个字段单独显示为一行
awk '{
if(NR==1){
print $1 &quot;\n&quot; $2 &quot;\n&quot; $3 &quot;\n&quot;
} else {
print}
}' test    #NR是awk内建的变量，表示当前处理的行数。 $n中的n为相应的字段号
或者
awk '{
if(NR==1){
OFS=&quot;\n&quot;
print $1,$2,$3
} else {
print}
}' test    #OFS是awk内建的变量，表示输出时的字段分隔符，默认为空格。    

将test的第二行以点分布的字段换成以空格为分隔
awk -F'.' '{
if(NR==2){
print $1 &quot;\t&quot; $2 &quot;\t&quot; $3 &quot;\t&quot;    #print打印的非变量内容都需要用&quot;&quot;包围起来
}}' test    #-F用来预先指定待处理记录的字段分隔符
或者
awk '
BEGIN{    #BEGIN这个表达式指示了其后的动作将在所有动作之前执行。
FS=&quot;.&quot;
OFS=&quot;\t&quot;
}{
if(NR==2){
print $1,$2,$3
}}' test    
</code></pre>
<p><a href="https://coolshell.cn/articles/9070.html">参考网址1</a><br>
<a href="https://awk.readthedocs.io/en/latest/chapter-one.html">参考网址2</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_查看历史数据/命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-cha-kan-li-shi-shu-ju-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-cha-kan-li-shi-shu-ju-ming-ling/">
        </link>
        <updated>2020-03-17T04:16:48.000Z</updated>
        <content type="html"><![CDATA[<p>在linux中，对于文本的处理和分析是极为重要的，现在有一个文件（file1）里面记载了一些数据，现在请你找出这个文件（file1）中出现频率前三的数据并保存在<code>/home/directory</code>中。</p>
<h1 id="目标">目标</h1>
<ol>
<li>处理文本文件<code>file1</code></li>
<li>结果包含三行内容，每行的内容都包含命令出现的次数和命令名称</li>
<li>将结果输入到<code>/home/directory</code>中</li>
</ol>
<h2 id="目标分析">目标分析</h2>
<p>注意使用管道<code>|</code></p>
<ol start="4">
<li>首先要查看文件内容<code>cat</code></li>
<li>将不相关的数据剔除掉<code>cut</code></li>
<li>将命令排序<code>sort</code></li>
<li>去掉重复命令并显示行数<code>uniq</code></li>
<li>将命令重新排序，<code>sort</code>让它用数字排序（<code>n</code>），大的数字显示在上面<code>r</code>,然后指定按照第一列的数字排序(<code>-k1</code>)</li>
<li>只显示文件开头前三行部分（<code>head</code>）</li>
<li>将命令重定向到<code>directory</code>中</li>
</ol>
<h3 id="命令">命令</h3>
<pre><code class="language-cpp">cat file1 | cut -c 8- | sort | uniq -dc | sort -nr -k1 | head -3 &gt; /home/directory
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_数据流重定向]]></title>
        <id>https://ydPro-G.github.io/post/linux_-shu-ju-liu-chong-ding-xiang/</id>
        <link href="https://ydPro-G.github.io/post/linux_-shu-ju-liu-chong-ding-xiang/">
        </link>
        <updated>2020-03-17T04:15:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目的">目的</h1>
<p>1.重定向怎么用<br>
2.文件描述符(0,1,2)</p>
<h2 id="学习目录">学习目录</h2>
<ol>
<li>数据流重定向</li>
<li>简单的重定向</li>
<li>标准错误的重定向</li>
<li>使用<code>tee</code>命令重定向到多个文件</li>
<li>exec命令</li>
<li>创建文件描述符</li>
<li>关闭文件描述符</li>
<li>完全屏蔽命令的输出</li>
<li>使用xargs分割参数列表</li>
</ol>
<hr>
<h3 id="1数据流重定向">1.数据流重定向</h3>
<h4 id="命令">命令</h4>
<p><code>&gt;</code> : 覆盖文件内容并写入<br>
<code>&gt;&gt;</code>：在文件后面追加，不覆盖文件内容<br>
<code>&lt;</code>：和<code>&gt;</code>作用一样，表示从右到左<br>
<code>&lt;&lt;</code>:和<code>&gt;&gt;</code>作用一样，表示从右到左</p>
<hr>
<h3 id="2简单的重定向">2.简单的重定向</h3>
<h4 id="前置知识文件描述符">前置知识：文件描述符</h4>
<pre><code class="language-bash"> 1.  文件描述符：0   设备文件：/dev/stdin    缩写：stdin    说明：标准输入
 2.  文件描述符：1   设备文件：/dev/stdout   缩写：stdout   说明：标准输出
 3.  文件描述符：2   设备文件：/dev/stderr   缩写：stderr   说明：标准错误
</code></pre>
<p><a href="https://blog.csdn.net/xlinsist/article/details/51147212">参考网址</a></p>
<p>实例（1：</p>
<pre><code class="language-bash">mkdir Documents #创建目录
cat &gt; Documents/test.c &lt;&lt; EOF   #将cat的连续输出重定向到一个文件中
#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;hello world/n&quot;);
    return 0;
}
EOF
</code></pre>
<p>补充<code>EOF</code>：<br>
是END Of File的缩写,表示自定义终止符.既然自定义,那么EOF就不是固定的,可以随意设置别名,在linux按ctrl-d就代表EOF.<br>
EOF一般会配合cat能够多行文本输出.<br>
其用法如下:<br>
&lt;&lt;EOF        //开始<br>
....<br>
EOF            //结束<br>
<a href="https://www.cnblogs.com/xiaojianblogs/p/6486902.html">参考网址</a></p>
<p><code>cat Documents/test.c</code></p>
<p>意义：将一个文件作为命令的输入（cat），标准输出作为命令的输出</p>
<p>实例（2：</p>
<pre><code class="language-cpp"> #将echo命令的输出从默认的标准输出重定向到一个普通文件
echo 'hello world' &gt; file 
#查看文件
cat file  
</code></pre>
<hr>
<h3 id="3标准错误的重定向">3.标准错误的重定向</h3>
<p>实例（1：</p>
<pre><code class="language-cpp"> #用bash提供的特殊的重定向符号“&amp;”将标准错误和标准输出同时重定向到文件
 cat [目录]/[标准输出文件] [标准错误文件] &amp;&gt; [文件] 
</code></pre>
<p>实例（2：</p>
<pre><code class="language-cpp">#将标准错误重定向到标准输出，将标准输出重定向到文件中，注意要将标准输出重定向到文件写在前面
cat [目录]/[标准输出文件] [标准错误文件] &gt; [文件] 2&gt;&amp;1 
</code></pre>
<p>补充：在输出重定向文件描述符前加上<code>&amp;</code>，否则shell会当作重定向到一个文件名为1的文件中</p>
<hr>
<h3 id="4使用tee命令同时重定向到多个文件">4.使用tee命令同时重定向到多个文件</h3>
<p>实例（1：</p>
<pre><code class="language-cpp">#将echo命令输出通过tee命令同时重定向到file1 file2 file3
echo 'git is good' | tee file1 file2 file3  
</code></pre>
<hr>
<h3 id="5exec命令">5.exec命令</h3>
<p>调用并执行指定的命令。<br>
exec命令 用于调用并执行指令的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。</p>
<p>实例（1：</p>
<pre><code class="language-cpp">zsh #进入子shell
exec 1 &gt; somefile   #使用exec替换当前进程的重定向，将标准输出（1）重定向到文件中
#后面执行的命令都将重定向到文件中，知道使用exit退出当前子shell
ls            #ls命令重定向到文件（somefile）中
ll            #ll命令重定向到文件（somefile）中
pwd           #pwd命令重定向到文件（somefile）中
exit          #退出
cat somefile    #主进程查看文件（somefile）  ls ll  pwd命令会同时执行
</code></pre>
<p><a href="https://blog.csdn.net/yanggd1987/article/details/38926901">参考网址</a></p>
<h3 id="6创建文件描述符">6.创建文件描述符</h3>
<p>Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象。其实我们可以想象我们电脑的显示器和键盘在Linux系统中都被看作是文件，而它们都有相应的文件描述符与之对应。<br>
shell中有9个文件描述符，上面是用了它提供的默认的0,1,2文件描述符，另外我们还可以使用3—8文件描述符。</p>
<p><code>cat /dev/fd;ls -Al</code>:查看当前shell进程中打开的文件描述符。<br>
<code>;</code>:路径的分隔符</p>
<p>实例（1：</p>
<pre><code class="language-cpp">zsh #进入子shell
exec 3 &gt; somefile           #将文件描述符3重定向到文件中（somefile）
cat /dev/fd;ls -Al;cd -     #查看当前shell中打开的文件描述符
echo &quot;this is test&quot; &gt;&amp;3           #将echo命令的输出重定向到文件描述符3种
cat somefile           #查看文件（somefile）
exit           #退出
</code></pre>
<p><a href="https://blog.csdn.net/xlinsist/article/details/51147212">参考网址</a></p>
<hr>
<h3 id="7关闭文件描述符">7.关闭文件描述符</h3>
<p><code>exec 3&gt;&amp;-</code>:关闭文件描述符3</p>
<hr>
<h3 id="8完全屏蔽命令的输出">8.完全屏蔽命令的输出</h3>
<h4 id="前置知识">前置知识</h4>
<p><code>/dev/null</code>空设备，一般用来丢弃不需要的输出流</p>
<p>实例（1：</p>
<pre><code class="language-cpp">cat directory/file 1&gt;/dev/null 2&gt;&amp;1    
#将文件标准输出（1）重定向到/dev/null中，将标准错误（2）重定向到标准输出（1）中
</code></pre>
<p>补充：<br>
<code>cat</code>：连接多个文件并打印到标准输出</p>
<hr>
<h3 id="9使用xargs分割参数列表">9.使用xargs分割参数列表</h3>
<p>将列表参数转换成小块分段传递给其他命令，以避免参数列表过长问题。</p>
<p>实例（1：</p>
<pre><code class="language-cpp">cut -d: -f1 &lt; /etc/passwd | sort |xargs echo
 #将/etc/passwd文件按：分割，取第一个字段排序后，使用echo命令生成一个列表。
</code></pre>
<p><a href="https://wangchujiang.com/linux-command/c/xargs.html">参考网址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_简单的文本处理]]></title>
        <id>https://ydPro-G.github.io/post/linux_-jian-dan-de-wen-ben-chu-li/</id>
        <link href="https://ydPro-G.github.io/post/linux_-jian-dan-de-wen-ben-chu-li/">
        </link>
        <updated>2020-03-17T04:14:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目的">目的</h1>
<p>1.常见文本处理命令<br>
2.如何简单处理文本</p>
<h3 id="学习目录">学习目录</h3>
<ol>
<li>tr</li>
<li>col</li>
<li>join</li>
<li>paste</li>
</ol>
<hr>
<h3 id="1tr命令">1.tr命令</h3>
<p>将字符进行替换压缩和删除<br>
tr命令 可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。</p>
<p>实例：<code>echo 'hello world' | tr -d 'ol'</code><br>
意义：删除<strong>hello world</strong>中所有的<strong>ol</strong></p>
<p>实例：<code>echo 'hello world' | tr -s &quot;l&quot;</code><br>
将<strong>hello world</strong>中的<strong>l</strong>去重为一个<strong>l</strong></p>
<p>实例：<code>echo 'hello' | tr '[a-z]' '[A-Z]'</code><br>
：<code>echo 'HELLO | tr '[A-Z] '[a-z]'</code><br>
意义：将hello转换成HELLO<br>
将HELLO转换成hello<br>
<strong>大小写转换</strong><br>
<a href="https://wangchujiang.com/linux-command/c/tr.html">参考网址</a></p>
<hr>
<h3 id="2col命令">2.col命令</h3>
<p>过滤控制字符，<strong>col 命令可以将Tab换成对等数量的空格键，或反转这个操作。</strong><br>
col命令 是一个标准输入文本过滤器，它从标注输入设备读取文本内容，并把内容显示到标注输出设备。在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符&gt;和&gt;&gt;，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col命令则能有效滤除这些控制字符。</p>
<p>实例：<code>cat [目录/文件] | col -x | cat -A</code>:<br>
意义：使用<code>col -x</code>将相应目录的相关文件中的<code>tab</code>字符转换成<code>空格</code>，然后使用<code>cat -A</code>查看<br>
<code>cat -A</code>查看不可见字符<br>
<a href="https://wangchujiang.com/linux-command/c/col.html">参考网址</a></p>
<hr>
<h3 id="3join命令">3.join命令</h3>
<p>两个文件中<strong>指定栏位内容相同的行连接</strong>起来<br>
join命令 用来将<strong>两个文件</strong>中，<strong>指定栏位内容相同的行连接起来</strong>。找出两个文件中，指定栏位内容相同的行，并加以合并，再<strong>输出到标准输出设备</strong>。</p>
<p>实例：<br>
<code>&gt;</code>:覆盖文件内容并写入<br>
<code>&gt;&gt;</code>:在文件后面追加，不覆盖<br>
<code>echo '1 hello' &gt; file1</code>:输入1 hello并覆盖文件内容写入file1文件中<br>
<code>echo '1 world' &gt; file2</code>:输入1 world并覆盖文件内容写入到file2文件中<br>
<code>join file1 file2</code>:输出<code>1 hello world</code>将<code>file1</code>和<code>file2</code>文件中包含相同内容（<code>1</code>）的那一行合并在一起。</p>
<p>实例：<code>sudo join -t':' /etc/passwd[目录/文件] /etc/shadow[目录/文件]</code>:<br>
意义：将两个文件合并，并指定以<code>':'</code>为分隔符<br>
<code>-t</code>：指定分隔符，默认为空格</p>
<p>实例：<code>sudo join -t':' -1 1 [目录/文件] -2 1 [目录/文件]</code><br>
意义：将2个文件合并，指定以<code>':'</code>作为分隔符，并对比第一字段和第二字段<br>
<code>-1</code>:指明第一个文件要用哪个字段来对比，默认是第一个字段<br>
<code>-2</code>:指明第二个文件要用哪个字段来对比，默认是第一个字段<br>
<a href="https://wangchujiang.com/linux-command/c/join.html">参考网址</a></p>
<h3 id="4paste命令">4.paste命令</h3>
<p>将多个文件按列队列合并<br>
paste命令 用于将多个文件按照列队列进行合并。</p>
<p>实例：<code>paste -d ':' [文件] [文件] [文件]</code><br>
意义：将三个文件合并在一起，<code>-d</code>指定分隔符为<code>':'</code>,默认为TAB</p>
<p>实例<code>paste -s [文件] [文件] [文件]</code><br>
意义：将三个文件合并在一起，<code>-s</code>不合并到一行，每个文件为一行。<br>
<a href="https://wangchujiang.com/linux-command/c/paste.html">参考网址</a></p>
<h2 id="复习">复习</h2>
<p>手动完成 dos 文本格式到 UNIX 文本格式的转换。</p>
<pre><code class="language-bash">echo hello &gt; file1
cat -A file1 |  tr '$' '\r\n' &gt; file2; cat -A file2
</code></pre>
<p>将unix文本转换成dos文本</p>
<pre><code class="language-bash">cat -A file2 | tr -d '^M$' &gt; file3; cat -A file3
</code></pre>
<p>将dos文本转换成unix文本</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_常用命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-chang-yong-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-chang-yong-ming-ling/">
        </link>
        <updated>2020-03-17T04:13:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>学习linux系统上的常用命令。</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>cut</li>
<li>grep</li>
<li>wc</li>
<li>sort</li>
<li>uniq</li>
</ol>
<h2 id="1cut命令">1.cut命令</h2>
<p>连接文件并打印到标准输出设备上</p>
<p>实例： <code>cut /etc/passwd -d '：' -f 1,6</code>:<br>
意义： 打印<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第1字段和第6字段。</p>
<p>实例：打印<code>etc/passwd</code>中指定的字段<br>
<code>cut /etc/passwd -c -7</code>:打印前七个字段（包含第七个）<br>
<code>cut /etc/passwd -c 7-</code>:打印前七个字段之后的字段（包含第七个）<br>
<code>cut /etc/passwd -c 7</code>:打印第七个字段<br>
<code>cut /etc/passwd -c 1-7</code>:打印1-7字段（包含第七个）<br>
<a href="https://wangchujiang.com/linux-command/c/cut.html">参考文章</a></p>
<hr>
<h3 id="2grep命令">2.grep命令</h3>
<p>强大的文本搜索工具，能够使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤搜索的特定字符。<br>
命令的一般形式：<code>grep [命令选项] &quot;[文件&quot;] 目录</code></p>
<p>实例：<code>grep -rnI &quot;vim&quot; ~（目录）</code>:<br>
意义：搜索当前目录下所有带有<code>vim</code> 的文本文件。并显示出现在文本中的行号。<br>
<code>r</code>:表示递归搜索子目录中的文件<br>
<code>n</code>：表示打印匹配行项行号<br>
<code>I</code>：表示忽略二进制文件</p>
<p>实例：<code>export | grep “.*a$”</code>:<br>
意义：查看环境变量中以<code>“a”</code>结尾的字符串<br>
<code>export</code>：为shell变量或函数设置导出属性<br>
<code>|</code>:管道<br>
<code>*</code>:所有<br>
<code>$</code>:表示一行的末尾，去掉就是搜索所有<br>
<a href="https://wangchujiang.com/linux-command/c/grep.html#!kw=export">参考文章</a></p>
<hr>
<h3 id="3wc命令">3.wc命令</h3>
<p>统计文件的字节数、字数、行数。</p>
<p>实例：<br>
<code>wc /etc/passwd</code>：输出<code>passwd</code>文件统计信息<br>
<code>wc -l /etc/passwd</code>:输出<code>passwd</code>文件行数<br>
<code>wc -w /etc/passwd</code>:输出<code>passwd</code>文件单词数<br>
<code>wc -c /etc/passwd</code>:输出<code>passwd</code>文件字节数<br>
<code>wc -m /etc/passwd</code>:输出<code>passwd</code>文件字符数<br>
<code>wc -L /etc/passwd</code>:输出<code>passwd</code>文件最长行字节数</p>
<p>结合<strong>管道</strong>文件实际运用：<br>
任务：统计<code>/etc</code>目录下面所有的目录数<br>
<code>ls -dl /etc/*/ | wc -l</code><br>
<a href="https://wangchujiang.com/linux-command/c/wc.html">参考文章</a></p>
<hr>
<h3 id="4sort命令">4.sort命令</h3>
<p>将文件进行排序并输出。</p>
<p><code>cat /etc/passwd | sort</code>:默认字典排序<br>
<code>cat /etc/passwd | sort -r</code>:反转排序</p>
<pre><code>cat /etc/passwd | sort -t `:` -k 3 -n
</code></pre>
<p>按特定字段排序<br>
<code>-t</code>：指定字段的分隔符<br>
<code>-k 3</code>：用于对哪一个字段进行排序<br>
<code>-n</code>：按照数字排序就要加上<code>-n</code> 参数<br>
<a href="https://wangchujiang.com/linux-command/c/sort.html">参考文章</a></p>
<hr>
<h3 id="uniq命令">uniq命令</h3>
<p>报告或忽略文件中的重复行</p>
<p>实例：<br>
<code>history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq</code><br>
意义：使用<code>history</code>命令查看最近执行过的命令，<code>cut</code>去掉命令后面的参数，然后用<code>sort</code>排序，最后用<code>uniq</code>全文去重。<br>
<code>uniq -dc</code>：输出重复过的行及重复次数<br>
<code>uniq -D</code>：输出所有重复的行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_管道]]></title>
        <id>https://ydPro-G.github.io/post/linux_-guan-dao/</id>
        <link href="https://ydPro-G.github.io/post/linux_-guan-dao/">
        </link>
        <updated>2020-03-17T04:10:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习目录">学习目录</h1>
<p>管道以文件形式存在<br>
<code>|</code></p>
<h2 id="命令">命令</h2>
<h3 id="1匿名管道">1.匿名管道：<code>|</code></h3>
<p>特点：只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样，子进程通过通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。<br>
<strong>优点</strong>：保证了传输数据的安全性。<br>
<strong>缺点</strong>：降低了管道通用性。</p>
<h3 id="2命名管道mkfifomknod">2.命名管道：<code>mkfifo</code>，<code>mknod</code></h3>
<p>实例：<code>mkfifo [管道名]</code>：有了这个管道文件，系统就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件通信了。<br>
<a href="https://zhuanlan.zhihu.com/p/58489873">参考文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_命令执行顺序]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ming-ling-zhi-xing-shun-xu/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ming-ling-zhi-xing-shun-xu/">
        </link>
        <updated>2020-03-17T04:08:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前提">前提：</h1>
<p>通常情况下，我们会在终端输入一条命令再输入下一条命令，可是如果我们想要一次性输入多个命令呢？</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>顺序执行多条命令</li>
<li>有选择的执行命令<br>
<code>&amp;&amp;</code><br>
<code>||</code></li>
</ol>
<h2 id="命令及实例">命令及实例</h2>
<h3 id="1顺序执行多条命令">1顺序执行多条命令</h3>
<p><code>sudo apt-get update</code>:更新源<br>
<code>sudo apt-get install [软件]</code>:下载具体的软件<br>
<code>[运行软件]</code>：运行具体的软件</p>
<p>如果想要<strong>一次性输完所有命令</strong>，让他们<strong>依次去执行</strong>可以用<code>;</code>来完成。</p>
<pre><code>sudo apt-get update;sudo apt-get install [软件];[软件]
</code></pre>
<hr>
<h1 id="2有选择的执行命令">2.有选择的执行命令</h1>
<h1 id="学习目录-2">学习目录</h1>
<p><code>&amp;&amp;</code><br>
<code>||</code></p>
<p>如果自动执行命令时，前面的命令不能执行，而后面的命令又依赖于上一条命令的结果，那么就会造成错误，这种情况下我们就<strong>需要有一个判断公式</strong>来判断上一条命令执行成功后再执行下一条命令，或者不成功我们又该做出其他的处理。</p>
<h4 id="实例">实例：</h4>
<pre><code>which cowsay&gt;/dev/null &amp;&amp; coway -f head-in ohch~
</code></pre>
<p>程序含义：<br>
<code>whoch cowsay&gt;/dev/null</code>:查询<code>cowsay[文件]</code>是否在目录<code>/dev/null</code>中。<br>
<code>&amp;&amp;</code>：用来实现选择性执行，如果前面的命令执行状态的结果返回0（即查询到）就执行后面，否则就不执行。<br>
<code>cowsay -f head-in ohch~</code>：<code>cowsay</code>【牛】在<code>-f head-in</code>头部聊天框中显示ohch~</p>
<h5 id="补充">补充</h5>
<p><code>||</code>在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令。</p>
<h3 id="如何得知命令执行状态的返回结果是否为0或1">如何得知命令执行状态的返回结果是否为0或1？</h3>
<p>先查询这个文件<br>
<code>which [文件]</code><br>
然后可以从<code>&amp;</code>环境变量中获取上一次命令的返回结果<br>
<code>echo $?</code></p>
<h3 id="也可以结合着和来实现一些操作">也可以结合着&amp;&amp;和||来实现一些操作</h3>
<p>实例：<br>
<code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist || echo &quot;not exist&quot;</code><br>
流程图<br>
<img src="https://img-blog.csdnimg.cn/20191214112718759.png" alt="l流程图" loading="lazy"></p>
<h4 id="将和反过来行不行">将<code>&amp;&amp;</code>和<code>||</code>反过来行不行？</h4>
<p>将<code>&amp;&amp;</code>和<code>||</code>反过来结果不一样<br>
<code>which cowsay&gt;/dev/null || echo &quot;exist &amp;&amp; echo &quot;not exist&quot;</code><br>
输出<code>not exist</code> <code>exist</code>两个都输出<br>
为什么？<br>
<code>which cowsay&gt;/dev/null</code>的结果不是0,所以<code>||</code>后面的语句会被执行,而且,<code>||</code>之后的语句成功执行之后,<code>#?</code>的值因为成功执行了<code>||</code>后面的语句变成了0,所以<code>&amp;&amp;</code>后面的语句执行了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_备份日志]]></title>
        <id>https://ydPro-G.github.io/post/linux_-bei-fen-ri-zhi/</id>
        <link href="https://ydPro-G.github.io/post/linux_-bei-fen-ri-zhi/">
        </link>
        <updated>2020-03-17T04:07:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="备份日志">备份日志</h1>
<p>要求:<br>
他需要每天备份论坛数据（这里我们用 alternatives.log 日志），备份当天的日志并删除之前的日志。而且备份之后文件名是 年-月-日 的格式。alternatives.log 在 /var/log/ 下面。<br>
1.为 shiyanlou 用户添加计划任务<br>
2.每天凌晨 3 点的时候定时备份 alternatives.log 到 /home/world/tmp/ 目录<br>
3.命名格式为 年-月-日，比如今天是2017年4月1日，那么文件名为 2017-04-01</p>
<p>解答：<br>
1.进入crontab -e 添加<br>
2.在3点将/home/world/tmp/所有文件清零<br>
3.在3点将在/var/log目录下的alternatives.log文件<code>CP</code>到 /home/world/tmp文件中,然后以年-月-日命名文件</p>
<pre><code>1.
crontab -e
choose vim
# 添加例行性工作排程
2.
0 3 * * * sudo rm /home/world/tmp/*
#清零
3.
0 3 * * * sudo cp /var/log/alternatives.log /home/wrold/tmp/$(date +$/%Y-/%m-/%d)
cp文件并重命名
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_例行性工作排程]]></title>
        <id>https://ydPro-G.github.io/post/linux_-li-xing-xing-gong-zuo-pai-cheng/</id>
        <link href="https://ydPro-G.github.io/post/linux_-li-xing-xing-gong-zuo-pai-cheng/">
        </link>
        <updated>2020-03-17T03:43:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是例行性工作排程">什么是例行性工作排程？</h1>
<p>1.有的工作是例行性的，比如吃饭<br>
2.有的工作是临时发生的，比如请别人吃饭<br>
<code>at</code>：at是个可以处理仅执行一次就结束排程的指令，不过要执行at时，必须要有atd这个服务的支援才行。<br>
<code>crontab</code>：crontab这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab除了可以使用指令执行外，亦可编辑/etc/crontab来支援。</p>
<h1 id="学习目录">学习目录</h1>
<p><code>crontab</code>的使用</p>
<h2 id="语法">语法</h2>
<p><code>corntab</code>(选项)（参数）<br>
<img src="https://ydPro-G.github.io//post-images/1584416805307.png" alt="" loading="lazy"></p>
<h2 id="选项">选项</h2>
<pre><code>-e：编辑该用户的计时器设置；
-l：列出该用户的计时器设置；
-r：删除该用户的计时器设置；
-u&lt;用户名称&gt;：指定要设定计时器的用户名称。
</code></pre>
<h2 id="命令">命令</h2>
<p><code>crontab -e</code>:编辑用户的计时器设置</p>
<h2 id="系统级别的定时任务">系统级别的定时任务</h2>
<p>用<code>sudo</code>的权限编辑<code>/etc/crontab</code></p>
<p>参考：<a href="http://linux.vbird.org/linux_basic/0430cron.php">Linux例行性工作排程——Linux鸟哥的私房菜</a></p>
]]></content>
    </entry>
</feed>