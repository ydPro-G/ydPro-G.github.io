<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ydPro-G.github.io/</id>
    <title>ydPro Blog</title>
    <updated>2020-03-17T04:15:35.418Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ydPro-G.github.io/"/>
    <link rel="self" href="https://ydPro-G.github.io/atom.xml"/>
    <subtitle>Life &amp; Work</subtitle>
    <logo>https://ydPro-G.github.io/images/avatar.png</logo>
    <icon>https://ydPro-G.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ydPro Blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux_简单的文本处理]]></title>
        <id>https://ydPro-G.github.io/post/linux_-jian-dan-de-wen-ben-chu-li/</id>
        <link href="https://ydPro-G.github.io/post/linux_-jian-dan-de-wen-ben-chu-li/">
        </link>
        <updated>2020-03-17T04:14:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目的">目的</h1>
<p>1.常见文本处理命令<br>
2.如何简单处理文本</p>
<h3 id="学习目录">学习目录</h3>
<ol>
<li>tr</li>
<li>col</li>
<li>join</li>
<li>paste</li>
</ol>
<hr>
<h3 id="1tr命令">1.tr命令</h3>
<p>将字符进行替换压缩和删除<br>
tr命令 可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。</p>
<p>实例：<code>echo 'hello world' | tr -d 'ol'</code><br>
意义：删除<strong>hello world</strong>中所有的<strong>ol</strong></p>
<p>实例：<code>echo 'hello world' | tr -s &quot;l&quot;</code><br>
将<strong>hello world</strong>中的<strong>l</strong>去重为一个<strong>l</strong></p>
<p>实例：<code>echo 'hello' | tr '[a-z]' '[A-Z]'</code><br>
：<code>echo 'HELLO | tr '[A-Z] '[a-z]'</code><br>
意义：将hello转换成HELLO<br>
将HELLO转换成hello<br>
<strong>大小写转换</strong><br>
<a href="https://wangchujiang.com/linux-command/c/tr.html">参考网址</a></p>
<hr>
<h3 id="2col命令">2.col命令</h3>
<p>过滤控制字符，<strong>col 命令可以将Tab换成对等数量的空格键，或反转这个操作。</strong><br>
col命令 是一个标准输入文本过滤器，它从标注输入设备读取文本内容，并把内容显示到标注输出设备。在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符&gt;和&gt;&gt;，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col命令则能有效滤除这些控制字符。</p>
<p>实例：<code>cat [目录/文件] | col -x | cat -A</code>:<br>
意义：使用<code>col -x</code>将相应目录的相关文件中的<code>tab</code>字符转换成<code>空格</code>，然后使用<code>cat -A</code>查看<br>
<code>cat -A</code>查看不可见字符<br>
<a href="https://wangchujiang.com/linux-command/c/col.html">参考网址</a></p>
<hr>
<h3 id="3join命令">3.join命令</h3>
<p>两个文件中<strong>指定栏位内容相同的行连接</strong>起来<br>
join命令 用来将<strong>两个文件</strong>中，<strong>指定栏位内容相同的行连接起来</strong>。找出两个文件中，指定栏位内容相同的行，并加以合并，再<strong>输出到标准输出设备</strong>。</p>
<p>实例：<br>
<code>&gt;</code>:覆盖文件内容并写入<br>
<code>&gt;&gt;</code>:在文件后面追加，不覆盖<br>
<code>echo '1 hello' &gt; file1</code>:输入1 hello并覆盖文件内容写入file1文件中<br>
<code>echo '1 world' &gt; file2</code>:输入1 world并覆盖文件内容写入到file2文件中<br>
<code>join file1 file2</code>:输出<code>1 hello world</code>将<code>file1</code>和<code>file2</code>文件中包含相同内容（<code>1</code>）的那一行合并在一起。</p>
<p>实例：<code>sudo join -t':' /etc/passwd[目录/文件] /etc/shadow[目录/文件]</code>:<br>
意义：将两个文件合并，并指定以<code>':'</code>为分隔符<br>
<code>-t</code>：指定分隔符，默认为空格</p>
<p>实例：<code>sudo join -t':' -1 1 [目录/文件] -2 1 [目录/文件]</code><br>
意义：将2个文件合并，指定以<code>':'</code>作为分隔符，并对比第一字段和第二字段<br>
<code>-1</code>:指明第一个文件要用哪个字段来对比，默认是第一个字段<br>
<code>-2</code>:指明第二个文件要用哪个字段来对比，默认是第一个字段<br>
<a href="https://wangchujiang.com/linux-command/c/join.html">参考网址</a></p>
<h3 id="4paste命令">4.paste命令</h3>
<p>将多个文件按列队列合并<br>
paste命令 用于将多个文件按照列队列进行合并。</p>
<p>实例：<code>paste -d ':' [文件] [文件] [文件]</code><br>
意义：将三个文件合并在一起，<code>-d</code>指定分隔符为<code>':'</code>,默认为TAB</p>
<p>实例<code>paste -s [文件] [文件] [文件]</code><br>
意义：将三个文件合并在一起，<code>-s</code>不合并到一行，每个文件为一行。<br>
<a href="https://wangchujiang.com/linux-command/c/paste.html">参考网址</a></p>
<h2 id="复习">复习</h2>
<p>手动完成 dos 文本格式到 UNIX 文本格式的转换。</p>
<pre><code class="language-bash">echo hello &gt; file1
cat -A file1 |  tr '$' '\r\n' &gt; file2; cat -A file2
</code></pre>
<p>将unix文本转换成dos文本</p>
<pre><code class="language-bash">cat -A file2 | tr -d '^M$' &gt; file3; cat -A file3
</code></pre>
<p>将dos文本转换成unix文本</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_常用命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-chang-yong-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-chang-yong-ming-ling/">
        </link>
        <updated>2020-03-17T04:13:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>学习linux系统上的常用命令。</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>cut</li>
<li>grep</li>
<li>wc</li>
<li>sort</li>
<li>uniq</li>
</ol>
<h2 id="1cut命令">1.cut命令</h2>
<p>连接文件并打印到标准输出设备上</p>
<p>实例： <code>cut /etc/passwd -d '：' -f 1,6</code>:<br>
意义： 打印<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第1字段和第6字段。</p>
<p>实例：打印<code>etc/passwd</code>中指定的字段<br>
<code>cut /etc/passwd -c -7</code>:打印前七个字段（包含第七个）<br>
<code>cut /etc/passwd -c 7-</code>:打印前七个字段之后的字段（包含第七个）<br>
<code>cut /etc/passwd -c 7</code>:打印第七个字段<br>
<code>cut /etc/passwd -c 1-7</code>:打印1-7字段（包含第七个）<br>
<a href="https://wangchujiang.com/linux-command/c/cut.html">参考文章</a></p>
<hr>
<h3 id="2grep命令">2.grep命令</h3>
<p>强大的文本搜索工具，能够使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤搜索的特定字符。<br>
命令的一般形式：<code>grep [命令选项] &quot;[文件&quot;] 目录</code></p>
<p>实例：<code>grep -rnI &quot;vim&quot; ~（目录）</code>:<br>
意义：搜索当前目录下所有带有<code>vim</code> 的文本文件。并显示出现在文本中的行号。<br>
<code>r</code>:表示递归搜索子目录中的文件<br>
<code>n</code>：表示打印匹配行项行号<br>
<code>I</code>：表示忽略二进制文件</p>
<p>实例：<code>export | grep “.*a$”</code>:<br>
意义：查看环境变量中以<code>“a”</code>结尾的字符串<br>
<code>export</code>：为shell变量或函数设置导出属性<br>
<code>|</code>:管道<br>
<code>*</code>:所有<br>
<code>$</code>:表示一行的末尾，去掉就是搜索所有<br>
<a href="https://wangchujiang.com/linux-command/c/grep.html#!kw=export">参考文章</a></p>
<hr>
<h3 id="3wc命令">3.wc命令</h3>
<p>统计文件的字节数、字数、行数。</p>
<p>实例：<br>
<code>wc /etc/passwd</code>：输出<code>passwd</code>文件统计信息<br>
<code>wc -l /etc/passwd</code>:输出<code>passwd</code>文件行数<br>
<code>wc -w /etc/passwd</code>:输出<code>passwd</code>文件单词数<br>
<code>wc -c /etc/passwd</code>:输出<code>passwd</code>文件字节数<br>
<code>wc -m /etc/passwd</code>:输出<code>passwd</code>文件字符数<br>
<code>wc -L /etc/passwd</code>:输出<code>passwd</code>文件最长行字节数</p>
<p>结合<strong>管道</strong>文件实际运用：<br>
任务：统计<code>/etc</code>目录下面所有的目录数<br>
<code>ls -dl /etc/*/ | wc -l</code><br>
<a href="https://wangchujiang.com/linux-command/c/wc.html">参考文章</a></p>
<hr>
<h3 id="4sort命令">4.sort命令</h3>
<p>将文件进行排序并输出。</p>
<p><code>cat /etc/passwd | sort</code>:默认字典排序<br>
<code>cat /etc/passwd | sort -r</code>:反转排序</p>
<pre><code>cat /etc/passwd | sort -t `:` -k 3 -n
</code></pre>
<p>按特定字段排序<br>
<code>-t</code>：指定字段的分隔符<br>
<code>-k 3</code>：用于对哪一个字段进行排序<br>
<code>-n</code>：按照数字排序就要加上<code>-n</code> 参数<br>
<a href="https://wangchujiang.com/linux-command/c/sort.html">参考文章</a></p>
<hr>
<h3 id="uniq命令">uniq命令</h3>
<p>报告或忽略文件中的重复行</p>
<p>实例：<br>
<code>history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq</code><br>
意义：使用<code>history</code>命令查看最近执行过的命令，<code>cut</code>去掉命令后面的参数，然后用<code>sort</code>排序，最后用<code>uniq</code>全文去重。<br>
<code>uniq -dc</code>：输出重复过的行及重复次数<br>
<code>uniq -D</code>：输出所有重复的行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_管道]]></title>
        <id>https://ydPro-G.github.io/post/linux_-guan-dao/</id>
        <link href="https://ydPro-G.github.io/post/linux_-guan-dao/">
        </link>
        <updated>2020-03-17T04:10:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习目录">学习目录</h1>
<p>管道以文件形式存在<br>
<code>|</code></p>
<h2 id="命令">命令</h2>
<h3 id="1匿名管道">1.匿名管道：<code>|</code></h3>
<p>特点：只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样，子进程通过通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。<br>
<strong>优点</strong>：保证了传输数据的安全性。<br>
<strong>缺点</strong>：降低了管道通用性。</p>
<h3 id="2命名管道mkfifomknod">2.命名管道：<code>mkfifo</code>，<code>mknod</code></h3>
<p>实例：<code>mkfifo [管道名]</code>：有了这个管道文件，系统就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件通信了。<br>
<a href="https://zhuanlan.zhihu.com/p/58489873">参考文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_命令执行顺序]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ming-ling-zhi-xing-shun-xu/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ming-ling-zhi-xing-shun-xu/">
        </link>
        <updated>2020-03-17T04:08:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前提">前提：</h1>
<p>通常情况下，我们会在终端输入一条命令再输入下一条命令，可是如果我们想要一次性输入多个命令呢？</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>顺序执行多条命令</li>
<li>有选择的执行命令<br>
<code>&amp;&amp;</code><br>
<code>||</code></li>
</ol>
<h2 id="命令及实例">命令及实例</h2>
<h3 id="1顺序执行多条命令">1顺序执行多条命令</h3>
<p><code>sudo apt-get update</code>:更新源<br>
<code>sudo apt-get install [软件]</code>:下载具体的软件<br>
<code>[运行软件]</code>：运行具体的软件</p>
<p>如果想要<strong>一次性输完所有命令</strong>，让他们<strong>依次去执行</strong>可以用<code>;</code>来完成。</p>
<pre><code>sudo apt-get update;sudo apt-get install [软件];[软件]
</code></pre>
<hr>
<h1 id="2有选择的执行命令">2.有选择的执行命令</h1>
<h1 id="学习目录-2">学习目录</h1>
<p><code>&amp;&amp;</code><br>
<code>||</code></p>
<p>如果自动执行命令时，前面的命令不能执行，而后面的命令又依赖于上一条命令的结果，那么就会造成错误，这种情况下我们就<strong>需要有一个判断公式</strong>来判断上一条命令执行成功后再执行下一条命令，或者不成功我们又该做出其他的处理。</p>
<h4 id="实例">实例：</h4>
<pre><code>which cowsay&gt;/dev/null &amp;&amp; coway -f head-in ohch~
</code></pre>
<p>程序含义：<br>
<code>whoch cowsay&gt;/dev/null</code>:查询<code>cowsay[文件]</code>是否在目录<code>/dev/null</code>中。<br>
<code>&amp;&amp;</code>：用来实现选择性执行，如果前面的命令执行状态的结果返回0（即查询到）就执行后面，否则就不执行。<br>
<code>cowsay -f head-in ohch~</code>：<code>cowsay</code>【牛】在<code>-f head-in</code>头部聊天框中显示ohch~</p>
<h5 id="补充">补充</h5>
<p><code>||</code>在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令。</p>
<h3 id="如何得知命令执行状态的返回结果是否为0或1">如何得知命令执行状态的返回结果是否为0或1？</h3>
<p>先查询这个文件<br>
<code>which [文件]</code><br>
然后可以从<code>&amp;</code>环境变量中获取上一次命令的返回结果<br>
<code>echo $?</code></p>
<h3 id="也可以结合着和来实现一些操作">也可以结合着&amp;&amp;和||来实现一些操作</h3>
<p>实例：<br>
<code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist || echo &quot;not exist&quot;</code><br>
流程图<br>
<img src="https://img-blog.csdnimg.cn/20191214112718759.png" alt="l流程图" loading="lazy"></p>
<h4 id="将和反过来行不行">将<code>&amp;&amp;</code>和<code>||</code>反过来行不行？</h4>
<p>将<code>&amp;&amp;</code>和<code>||</code>反过来结果不一样<br>
<code>which cowsay&gt;/dev/null || echo &quot;exist &amp;&amp; echo &quot;not exist&quot;</code><br>
输出<code>not exist</code> <code>exist</code>两个都输出<br>
为什么？<br>
<code>which cowsay&gt;/dev/null</code>的结果不是0,所以<code>||</code>后面的语句会被执行,而且,<code>||</code>之后的语句成功执行之后,<code>#?</code>的值因为成功执行了<code>||</code>后面的语句变成了0,所以<code>&amp;&amp;</code>后面的语句执行了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_备份日志]]></title>
        <id>https://ydPro-G.github.io/post/linux_-bei-fen-ri-zhi/</id>
        <link href="https://ydPro-G.github.io/post/linux_-bei-fen-ri-zhi/">
        </link>
        <updated>2020-03-17T04:07:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="备份日志">备份日志</h1>
<p>要求:<br>
他需要每天备份论坛数据（这里我们用 alternatives.log 日志），备份当天的日志并删除之前的日志。而且备份之后文件名是 年-月-日 的格式。alternatives.log 在 /var/log/ 下面。<br>
1.为 shiyanlou 用户添加计划任务<br>
2.每天凌晨 3 点的时候定时备份 alternatives.log 到 /home/world/tmp/ 目录<br>
3.命名格式为 年-月-日，比如今天是2017年4月1日，那么文件名为 2017-04-01</p>
<p>解答：<br>
1.进入crontab -e 添加<br>
2.在3点将/home/world/tmp/所有文件清零<br>
3.在3点将在/var/log目录下的alternatives.log文件<code>CP</code>到 /home/world/tmp文件中,然后以年-月-日命名文件</p>
<pre><code>1.
crontab -e
choose vim
# 添加例行性工作排程
2.
0 3 * * * sudo rm /home/world/tmp/*
#清零
3.
0 3 * * * sudo cp /var/log/alternatives.log /home/wrold/tmp/$(date +$/%Y-/%m-/%d)
cp文件并重命名
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_例行性工作排程]]></title>
        <id>https://ydPro-G.github.io/post/linux_-li-xing-xing-gong-zuo-pai-cheng/</id>
        <link href="https://ydPro-G.github.io/post/linux_-li-xing-xing-gong-zuo-pai-cheng/">
        </link>
        <updated>2020-03-17T03:43:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是例行性工作排程">什么是例行性工作排程？</h1>
<p>1.有的工作是例行性的，比如吃饭<br>
2.有的工作是临时发生的，比如请别人吃饭<br>
<code>at</code>：at是个可以处理仅执行一次就结束排程的指令，不过要执行at时，必须要有atd这个服务的支援才行。<br>
<code>crontab</code>：crontab这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab除了可以使用指令执行外，亦可编辑/etc/crontab来支援。</p>
<h1 id="学习目录">学习目录</h1>
<p><code>crontab</code>的使用</p>
<h2 id="语法">语法</h2>
<p><code>corntab</code>(选项)（参数）<br>
<img src="https://ydPro-G.github.io//post-images/1584416805307.png" alt="" loading="lazy"></p>
<h2 id="选项">选项</h2>
<pre><code>-e：编辑该用户的计时器设置；
-l：列出该用户的计时器设置；
-r：删除该用户的计时器设置；
-u&lt;用户名称&gt;：指定要设定计时器的用户名称。
</code></pre>
<h2 id="命令">命令</h2>
<p><code>crontab -e</code>:编辑用户的计时器设置</p>
<h2 id="系统级别的定时任务">系统级别的定时任务</h2>
<p>用<code>sudo</code>的权限编辑<code>/etc/crontab</code></p>
<p>参考：<a href="http://linux.vbird.org/linux_basic/0430cron.php">Linux例行性工作排程——Linux鸟哥的私房菜</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_磁盘管理]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ci-pan-guan-li/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ci-pan-guan-li/">
        </link>
        <updated>2020-03-17T03:40:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习目录">学习目录</h1>
<ol>
<li>基本操作</li>
<li>简单的磁盘管理</li>
</ol>
<h2 id="基本操作">基本操作</h2>
<p><code>df -h</code>:查看主机磁盘的使用情况。<br>
<img src="https://ydPro-G.github.io//post-images/1584416473896.png" alt="" loading="lazy"><br>
物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。<br>
<code>du -h</code>查看目录的容量<br>
<code>du -h -d 0 ~</code>只查看一级目录信息<br>
<code>du -h -d 1 ~</code>只查看二级目录信息<br>
<code>-d</code>:指定查看目录的深度<br>
<code>-a</code>：显示目录中所有文件的大小<br>
<code>-s</code>;仅显示总计</p>
<h2 id="简单磁盘操作">简单磁盘操作</h2>
<p>dd也可以用在<strong>备份硬件的引导扇区</strong>、获取<strong>一定数量的随机数据或者空数据</strong>等任务中。dd程序也可以在<strong>复制时处理数据</strong>，例如<strong>转换字节序</strong>、或在 <strong>ASCII 与 EBCDIC 编码间互换</strong>。</p>
<p>dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为<strong>选项=值</strong>，而不是更标准的**--选项 值<strong>或-<strong>选项=值</strong>。dd默认从</strong>标准输入中读取**，并<strong>写入到标准输出中</strong>，但可以<strong>用选项if（input file</strong>，<strong>输入文件</strong>）和<strong>of（output file</strong>，<strong>输出文件</strong>）改变。</p>
<h3 id="1从标准输入读取用户输入输入到标准输出或文件中">1.从标准输入读取用户输入，输入到标准输出或文件中</h3>
<p><code>dd of=test bs=10 count=1</code>:从标准输入中读取用户的输入，然后输入到标准输出中或一个文件中。<br>
<code>of=test</code>:<code>of</code>定义输出，<code>test</code>为输出到的文件名。<br>
<code>bs=10</code>:<code>bs(block size)</code>指定块大小（单位默认为Byte，也可指定K，M，G单位<code>bs=1M</code>）,<code>10</code>只读取10字节的数据。<br>
<code>count=1</code>:指定块数量,<code>1</code>只有1块<br>
<strong>注意：</strong><br>
<strong>空格回车</strong>也算一字节。</p>
<h3 id="2dd命令在拷贝的同时实现数据转换例大小写转换">2.dd命令在拷贝的同时实现数据转换（例：大小写转换）</h3>
<p><code>dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</code>:将标准输入中的小写字母转换成大写字母<br>
<code>/dev/stdin</code>:dev/stdin      fd/0            symbolic        stdin(标准输入)文件描述<br>
参考链接：<a href="https://blog.csdn.net/sinat_36184075/article/details/71598834">设备文件dev详解</a><br>
<code>conv=ucare</code>:将小写字母转换成大写字母</p>
<h3 id="3使用dd命令创建虚拟镜像文件">3.使用dd命令创建虚拟镜像文件</h3>
<p><code>dd if=/dev/zero of=virtual.img bs=1M count=256</code>:从/dev/zero设备创建一个容量为256M的空文件。<br>
<code>sudo mkfs.ext4 virtual.img</code>：将虚拟磁盘镜像格式化为ext4文件系统。<br>
<code>mount -o loop -t ext4 virtual.img /mnt</code>:将创建额虚拟磁盘镜像挂在在/mnt目录<br>
<code>mount -o loop --ro virtual.img /mnt</code>:以只读的方式挂载<br>
<code>sudo umount /mnt</code>:使用umount命令卸载已挂载磁盘</p>
<h3 id="4磁盘分区">4.磁盘分区</h3>
<p><code>sudo fdisk -l</code>查看硬盘分区表信息<br>
<code>sudo fdisk virtual.img</code>；进入磁盘分区模式<br>
<code>sudo losetuo /dev/loopO virtual.img</code>:使用losetup命令建立镜像与回环设备的关联<br>
<code>sudo losetup -d /dev/loopO</code>:解除设备关联</p>
<p>之后是使用<code>mkfs</code>格式化各分区，不过格式化前，我们还要为各分区建立虚拟设备的映射，用到kpartx工具，需要先安装<br>
<code>sudo apt-get install kpartx</code><br>
<code>sudp kpartx -av /dev/loopO</code><br>
取消映射：<br>
<code>sudo kpartx -dv /dev/loopO</code><br>
全部格式化为ext4：<br>
<code>sudo mkfs.ext4 -q /dev/mapper/loopOp1</code><br>
<code>sudo mkfs.ext4 -q /dev/mapper/loopOp5</code><br>
<code>sudo mkfs.ext4 -q /dev/mapper/loopOp6</code><br>
格式化完成后在<code>/media</code>目录下新建四个空目录用于挂载虚拟磁盘：<br>
<code>mkdir -p /media/virtualdisk_{1..3}</code><br>
挂载磁盘分区：<br>
<code>sudo mount /dev/mapper/loopOp1 /media/virtualdisk_1</code><br>
<code>sudo mount /dev/mapper/loopOp5 /media/virtualdisk_2</code><br>
<code>sudo mount /dev/mapper/loopOp6 /media/virtualdisk_3</code><br>
卸载磁盘分区：<br>
<code>sudo umount /dev/mapper/loopOp1</code><br>
<code>sudo umount /dev/mapper/loopOp5</code><br>
<code>sudo umount /dev/mapper/loopOp6</code></p>
<p>如何找到当前目录下占用最大的前十个文件：<br>
<code>du -hsx * | sort -rh | head -10</code><br>
<code>du -hsx</code>:显示每个文件和目录的磁盘使用空间<br>
<code>-h</code>或--human-readable 以K，M，G为单位，提高信息的可读性。<br>
<code>-s</code>或--summarize 仅显示总计，只列出最后加总的值。<br>
<code>-x</code>或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</p>
<p><code>sort -rh</code>:将文件进行排序并输出<br>
<code>-r</code>：以相反的顺序来排序；</p>
<p><code>head -10</code>:显示文件的开头部分。<br>
<code>-10</code>:显示前十个</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_压缩&打包&解压缩]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ya-suo-andda-bao-andjie-ya-suo/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ya-suo-andda-bao-andjie-ya-suo/">
        </link>
        <updated>2020-03-17T03:38:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>Linux上常用的压缩/解压工具，主要是zip，tar的使用。</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>zip命令</li>
<li>tar命令</li>
<li>压缩与解压常用组合</li>
</ol>
<h1 id="关键指令">关键指令</h1>
<p>1.zip：</p>
<ul>
<li>打包命令：zip something.zip something (目录加 -r 参数)</li>
<li>解包命令：unzip something.zip (指定解压路径加 -d 参数)</li>
</ul>
<hr>
<p>2.tar</p>
<ul>
<li>打包命令：tar -cf something.tar something</li>
<li>解压命令：tar -xf something.tar (指定路径 -C 参数)</li>
</ul>
<h2 id="1zip命令">1.zip命令</h2>
<p>命令：<br>
<code>zip -r -1 -l -e -q -o [文件名].zip [目录/文件]</code>：用zip命令打包文件夹<br>
<code>zip -r -9 -l -e -q -o [文件名].zip [目录/文件]</code>：用zip命令打包文件夹<br>
<code>-r</code>表示<strong>递归打包包含子目录的全部内容</strong>（打包目录要用<code>-r</code>）<br>
<code>-q</code>表示<strong>静默打包</strong>，不向屏幕输出信息<br>
<code>-o</code>表示输出文件，需要<strong>在后面紧跟打包输出的文件名</strong><br>
<code>-1</code>表示压缩等级：<strong>最快压缩但体积最大</strong><br>
<code>-9</code>表示压缩等级，<strong>体积最小但耗时最久</strong><br>
<code>-e</code>：<strong>创建加密压缩包</strong><br>
<code>-l</code>在linux中<strong>压缩</strong>可以在windows中<strong>解压</strong></p>
<p><code>du -h [压缩文件名].zip</code>查看文件打包后大小</p>
<h3 id="11使用unzip命令解压缩zip文件">1.1使用unzip命令解压缩zip文件</h3>
<p>命令：<br>
<code>unzip [文件名].zip</code>将文件解压到<strong>当前目录</strong><br>
<code>unzip -q [文件名].zip -d [指定目录]</code>将文件<strong>解压到指定目录</strong><br>
<code>unzip -l [文件名].zip</code><strong>不解压文件</strong>，只查看压缩包<strong>内容</strong>。<br>
<code>-l</code>不解压文件直接查看<br>
<strong>注意</strong>：<br>
在linux上打开中文解压包需要使用<code>-O</code>参数指定编码类型。<br>
<code>unzip -O GBK [中文名称文件].zip</code></p>
<h2 id="2tar打包工具">2.tar打包工具</h2>
<p>命令<br>
<code>tar -cf [文件名].tar [目录]</code>不进行压缩只进行打包<br>
<code>-c</code>：创建一个tar包文件<br>
<code>-f</code>：指定创建文件名，文件名必须紧跟在<code>-f</code>参数后</p>
<h3 id="21解包">2.1解包</h3>
<p><code>tar -xf [文件名].tar -C [已存在目录]</code>：解包一个文件到指定路径的<strong>已存在</strong>的目录<br>
<code>-x</code>解包文件参数<br>
<code>-C</code>指定路径参数</p>
<p><code>tar -tf [文件名].tar</code>:只查看不解包文件命令<br>
<code>-t</code>：只查看不解包参数<br>
<code>tar -cphf etc.tar /etc</code>:保留文件属性和跟随链接，有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）</p>
<h3 id="22创建不同的压缩格式文件">2.2创建不同的压缩格式文件</h3>
<p>命令;<br>
<code>tar -czf [文件名].tar.gz [目录/文件]</code>：用tar创建.gz压缩格式的文件。<br>
<code>-z</code>：压缩文件格式：<em>.tar.gz<br>
<code>-J</code>：压缩文件格式：</em>.tar.xz<br>
<code>-j</code>：压缩文件格式：*tar.bz2</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_环境变量]]></title>
        <id>https://ydPro-G.github.io/post/linux_-huan-jing-bian-liang/</id>
        <link href="https://ydPro-G.github.io/post/linux_-huan-jing-bian-liang/">
        </link>
        <updated>2020-03-17T03:35:34.000Z</updated>
        <content type="html"><![CDATA[<p>学习环境变量的作用与用法。</p>
<h1 id="1学习目录">1.学习目录</h1>
<ol>
<li>环境变量</li>
<li>命令的查找路径与顺序</li>
<li>添加自定义路径到PATH环境变量</li>
<li>修改和删除已有的变量</li>
<li>如何让环境变量立即生效</li>
</ol>
<h2 id="1变量">1.变量</h2>
<p>什么是环境变量？<br>
要解释环境变量，得先明白变量是什么，准确是说shell变量，所谓<strong>变量</strong>就是<strong>计算机中用来记录一个值</strong>（可能是数值也可能是字符或者字符串）<strong>的符号</strong>，而<strong>这些符号将用于不同的运算处理中</strong>。通常<strong>变量与值是一对一的关系</strong>，可以<strong>通过表达式读取它的值并赋值给其他变量</strong>，也可以<strong>直接指定数值赋值给任意变量。</strong><br>
为了便于运算和处理，大部分<strong>编程语言会区分变量的类型</strong>，用于分别记录数值，字符，字符串等数据类型。</p>
<h3 id="11创建变量">1.1创建变量</h3>
<p><code>declare [变量]</code>创建变量</p>
<h3 id="12变量赋值">1.2变量赋值</h3>
<p><code>[变量]=[数值]</code>用“=”赋值运算符</p>
<h3 id="13查找变量的值">1.3查找变量的值</h3>
<p><code>echo $[变量]</code></p>
<h2 id="2环境变量">2.环境变量</h2>
<p>环境变量的作用域比自定义变量大，如shell的环境变量作用于他的自身和它的子进程。</p>
<h3 id="21三种变量类型">2.1三种变量类型</h3>
<p>1.当前shell进程私有用户自定义变量，只在当前shell有效。<br>
2.shell本身内建的变量。<br>
3.从自定义变量导出的环境变量。</p>
<h3 id="22打印环境变量的三个命令">2.2打印环境变量的三个命令</h3>
<p><code>set</code>显示当前shell所有变量，包括其内建环境变量，用户自定义变量及导出的环境变量。<br>
<code>env</code>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。<br>
<code>export</code>显示从shell中导出成为环境变量的变量，也能通过他将自定义变量导出为环境变量。<br>
实际案例：<br>
<code>temp[变量名称]=hello[变量设置值]</code>定义一个变量<br>
<code>export temp_env[变量名称]=hello[变量设置值]</code>将自定义变量导出为环境变量<br>
参考：<a href="https://blog.csdn.net/wl_fln/article/details/7258294">linux export命令详解</a></p>
<p>如何将自定义变量设置为环境变量<br>
<img src="https://ydPro-G.github.io//post-images/1584416205608.png" alt="" loading="lazy"></p>
<h3 id="23环境变量永久生效">2.3环境变量永久生效</h3>
<p>按照变量的生存周期来划分，变量分为两种；<br>
1.<br>
<strong>永久</strong>：需要修改配置文件，变量永久生效。<br>
打开<code>/etc/profile</code>添加上想要添加的环境变量，这个环境变量就会变成永久的环境变量。<br>
2.<br>
<strong>临时性的</strong>：使用<code>export</code>命令即可，变量在关闭shell时失效。</p>
<h2 id="3命令的查找路径与顺序">3命令的查找路径与顺序</h2>
<p>简介：我们在shell中输入一个命令，shell怎么知道去哪里找到这个命令并且执行的呢？答案就是这是通过环境变量<code>PATH</code>来进行搜索的。<code>PATH</code>保存了shell中执行的命令的搜索路径。</p>
<h2 id="4添加自定义路径到path环境变量">4.添加自定义路径到PATH环境变量</h2>
<p><code>PATH</code>路径是以<code>：</code>作为分隔符的！<br>
<code>PATH=$PATH:[路径]</code>将自定义的<strong>绝对路径</strong>添加到PATH环境变量中，这样我们就可以在<br>
任意目录下使用这个【自定义路径】的命令了。<br>
但是，这样还<strong>有一个问题，<strong>它</strong>只对当前的shell有效</strong>，我一旦退出终端再打开就就会发现又失效了，有没有一种办法让我们可以让它在全局变量中有效？或者是<strong>让它每次使用的时候自动添加到到PATH中？</strong> 有！</p>
<h3 id="41自动执行">4.1自动执行</h3>
<p>在每个用户的home目录中，有一个shell每次启动时都会默认执行一个配置脚本，用来初始化环境，添加一些用户自定义的环境变量等等。<br>
zsh的配置文件是<code>.zshrc</code><br>
命令：<code>echo &quot;PATH=$PATH:[自定义路径]” &gt;&gt;.zshrc</code><br>
<code>&gt;&gt;</code>表示将标准输出以<strong>追加</strong>的方式重定义到一个文件中<br>
<code>&gt;</code>表示将标准输出以<strong>覆盖</strong>的方式重定义到一个文件中<br>
Bash的配置命令是<code>.bashrc</code><br>
命令：<code>echo ”PATH=$PATH:[自定义路径]&quot; &gt;&gt;.bashrc</code></p>
<h2 id="5修改和删除变量">5.修改和删除变量</h2>
<p>命令<br>
<code>${变量名#匹配字串}</code>从头向后开始匹配，删除符合匹配字串的最短数据<br>
<code>${变量名##匹配字串}</code>从头向后开始匹配，删除符合匹配字串的最长数据<br>
<code>${变量名%匹配字串}</code>从尾向前开始匹配，删除符合匹配字串的最短数据<br>
<code>${变量名%%匹配字串}</code>从尾向前开始匹配，删除符合匹配字串的最长数据<br>
<code>unset</code>删除变量</p>
<h3 id="6让环境变量立即生效">6.让环境变量立即生效</h3>
<p>命令<br>
<code>source [配置的脚本文件]</code>让环境变量立即生效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_搜索命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-sou-suo-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-sou-suo-ming-ling/">
        </link>
        <updated>2020-03-17T03:33:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="常用命令目录">常用命令目录</h1>
<p><code>whereis</code><br>
<code>locat</code><br>
<code>which</code><br>
<code>find</code></p>
<h2 id="whereis-简单快速">whereis 【简单快速】</h2>
<p><code>whereis [文件名]</code>：直接<strong>从数据库中查询</strong>。whereis 只能<strong>搜索二进制文件(-b)</strong>，man <strong>帮助文件(-m)<strong>和</strong>源代码文件(-s)</strong>。</p>
<h2 id="locate-快而全">locate 【快而全】</h2>
<p><code>locate /[目录]/[文件]</code>：用来查找<strong>指定目录</strong>下的<strong>不同文件类型</strong>。<br>
提示;<code>locate</code>通过数据库查找，不过这个数据库也<strong>不是实时更新</strong>的，系统会<strong>使用定时任务每天自动执行 updatedb 命令更新一次</strong>，所以有时候你刚添加的文件，它可能会找不到，需要<strong>手动执行一次 updatedb 命令.</strong><br>
<code>sudo apt-get update</code><br>
<code>sudo apt-get install locate</code><br>
<code>locate /[目录]/[文件]</code></p>
<p>查找<code>/usr/share/</code>下的所有.jpg文件<br>
<code>locate /usr/share/\*.jpg</code><br>
注意：<strong>添加 * 号前面的反斜杠转义</strong></p>
<h2 id="which-小而精">which 【小而精】</h2>
<p><code>which</code>：是 <strong>Shell 内建的一个命令</strong>，我们通常使用 which 来<strong>确定是否安装了某个指定的软件</strong>，因为它<strong>只从 PATH 环境变量指定的路径中去搜索命令。</strong><br>
<code>which [软件]</code></p>
<h2 id="find精而细">find【精而细】</h2>
<p><code>find</code>:可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索.<br>
用法：<code>sudo find [目录] [命令] [文件名]</code></p>
<p>查找<code>/etc/</code>目录下的名字叫做interfaces文件<br>
<code>sudo find /etc/ -name interfaces</code><br>
参数：<br>
<code>-atime</code>：最后访问时间<br>
<code>-ctime</code>:最后修改文件内容的时间<br>
<code>-mtime</code>:最后修改文件属性的时间</p>
<p>列出 home 目录中，当天（24 小时之内）有改动的文件<br>
<code>find ~ -mtime 0</code></p>
<p>列出用户home目录下比 Code 文件夹新的文件<br>
<code>find ~ -newer /home/shiyanlou/Code</code><br>
<code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</p>
]]></content>
    </entry>
</feed>