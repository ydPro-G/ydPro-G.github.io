<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ydPro-G.github.io/</id>
    <title>ydPro Blog</title>
    <updated>2020-03-17T04:20:54.614Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ydPro-G.github.io/"/>
    <link rel="self" href="https://ydPro-G.github.io/atom.xml"/>
    <subtitle>Life &amp; Work</subtitle>
    <logo>https://ydPro-G.github.io/images/avatar.png</logo>
    <icon>https://ydPro-G.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ydPro Blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux_进程概念]]></title>
        <id>https://ydPro-G.github.io/post/linux_-jin-cheng-gai-nian/</id>
        <link href="https://ydPro-G.github.io/post/linux_-jin-cheng-gai-nian/">
        </link>
        <updated>2020-03-17T04:20:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目标">目标</h1>
<p>对于linux进程有初步的概念（进程与程序，进程的衍生，工作管理）</p>
<hr>
<h2 id="学习目录">学习目录</h2>
<p>1.进程概念理解<br>
2.进程的属性<br>
2.1进程的分类<br>
2.2进程的衍生<br>
2.3进程组与sessions<br>
2.4工作管理</p>
<hr>
<h3 id="1进程概念理解">1.进程概念理解</h3>
<p>什么是程序，什么是进程？什么是线程？</p>
<h4 id="程序">程序：</h4>
<p>程序是一个<strong>静态的概念</strong>，一般对应一个操作系统中的一个可执行文件（待执行），由一系列<strong>有逻辑，有顺序结构的指令组成</strong>。</p>
<h4 id="进程">进程：</h4>
<p><strong>1.执行中的程序叫做进程，是一个动态的概念</strong>。</p>
<p>2.进程是包含<strong>上下文切换的程序执行时间总和</strong>，是<strong>对应的CPU时间段的描述</strong>，是描述这一CPU时间段的名词。<a href="https://www.zhihu.com/question/25532384/answer/81152571">参考网址</a></p>
<p>3.进程，是计算机中的程序关于某数据集合上的一次运动活动，是<strong>系统进行资源分配和调度的基本单位。<strong>是</strong>操作系统结构的基础</strong>。它的执行<strong>需要系统分配资源创建实体</strong>后才能进行。</p>
<p>4.在<strong>Linux2.6</strong>更新后，进程本身不是基本运行单位，而是<strong>线程的容器</strong>（只在Linux中）。</p>
<p>5 进程是<strong>程序的一次动态执行过程，占用特定的地址空间</strong>。</p>
<p>6.每个进程由三部分组成：<strong>代码段，数据段，进程控制块</strong>。<strong>每个进程都是独立的</strong>，拥有自己的cpu时间，代码和数据，即使一个程序产生了好几份进程，他们之间还是独立拥有自己的这三件东西，这样的<strong>缺点</strong>是：<strong>浪费内存，cpu负担较重</strong>。<a href="https://zhuanlan.zhihu.com/p/64884223">参考网址</a></p>
<h4 id="线程">线程：</h4>
<p>1.随着技术的发展，在执行一些细小任务时，本身无需分配单独资源，进程依然会繁琐的将资源分割，即浪费时间还浪费资源，然后专门运用于这个场景的<strong>多任务技术</strong>被创造——线程。<strong>进程可以产生多个线程</strong>，而这些线程可以<strong>共享</strong>此<strong>进程</strong>的某些<strong>资源</strong>，所以<strong>进程不需要独立的资源就可以运行</strong>，可以节省资源与时间。</p>
<p>2.进程是操作系统能够进行<strong>运算调度的最小单位</strong>。它被<strong>包含在进程内</strong>，是进程中<strong>实际运作单位</strong>。</p>
<p>3.<strong>线程</strong>是一个进程内部的一个执行单元，它是<strong>程序中的单一的顺序控制进程</strong>。</p>
<p>4.<strong>一个进程</strong>可<strong>拥有多个并行</strong>的<strong>线程</strong>（需多个cpu）。</p>
<p>5.<strong>一个进程</strong>内的<strong>多个线程共享相同的内存地址空间</strong>，可以<strong>访问相同的变量和对象</strong>，它们从同一堆中<strong>分配对象并进行通信，数据交换和同步操作</strong>。</p>
<p>6.它是<strong>比进程更为细小</strong>的<strong>cpu时间段</strong>。<br>
<a href="https://my.oschina.net/cnyinlinux/blog/422207">进程与线程区别参考网址</a></p>
<hr>
<h3 id="2进程的属性">2.进程的属性</h3>
<p>进程的属性分为（进程的分类）（进程的衍生）（进程组与sessions）（工作管理）。</p>
<hr>
<h3 id="21进程的分类">2.1进程的分类</h3>
<p>两个角度：<br>
一（进程的功能与服务的对象来分）<br>
二（应用程序的服务类型）</p>
<h4 id="进程的功能与服务对象">进程的功能与服务对象</h4>
<ul>
<li>用户进程：通过执行用户程序，应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li>
<li>系统进程：通过执行系统内核程序而产生的进程，而且该进程的运行不受用户干预。即使root用户也不能干预系统进程的运行。</li>
</ul>
<h4 id="应用程序的服务类型">应用程序的服务类型</h4>
<ul>
<li>交互进程：由shell终端启动的进程，在执行过程中，需要与用户进行交互操作。可以运行前台，也可以运行于后台。</li>
<li>守护进程：一种一直运行的进程。例如httpd进程。</li>
</ul>
<hr>
<h3 id="22进程的衍生">2.2进程的衍生</h3>
<ol>
<li>
<p>父进程与子进程：我们启动终端就是启动了一个bash进程，当我们在bash中再输入bash则会再启动一个bash进程。我们叫<strong>第一个bash进程为父进程</strong>，<strong>第二个bash进程为其子进程</strong>。</p>
</li>
<li>
<p><code>fork()</code>与<code>exec()</code>：<br>
<code>fork()</code>：是一个system call，主要作用是为当前进程创建一个新的进程，这个新进程就是它的子进程，这个子进程除了父进程的返回值和PID以外其他的信息都一模一样。<br>
<code>exec()</code>：也是系统调用，作用是切换子进程中的执行程序，替换其从父进程复制过来的代码段和数据段。</p>
</li>
<li>
<p>子进程退出与资源回收：当一个子进程要正常的终止运行时或该进程结束时它的主函数<code>main()</code>会执行<code>exit(n);</code>或<code>return n</code>，这里的<code>n</code>是一个信号，系统会将这个SIGCHLD信号返回给父进程。</p>
</li>
</ol>
<p>4.僵尸进程：当子进程代码执行部分已经结束执行，系统资源也基本归还给系统了，但若是其进程的进程控制块仍驻留在内存中，而它的PCB还在，代表这个进程还存在，并没有消亡<code>Z(Zombie)</code>表示僵尸进程。 缺点：子进程会占用PID，而系统会因为没有可用的PID从而导致不能产生新的进程。</p>
<p>5.孤儿进程：当父进程非正常结束，未能及时回收子进程，子进程仍在运行，这样的进程被称为孤儿进程。这样的进程会被init进程收养。</p>
<h4 id="6进程结构">6.进程结构</h4>
<p>进程0：是系统引导时创建的一个特殊进程，称为内核初始化，其最后一个动作就是调用<code>fork()</code>创建出一个子进程运行<code>/sbin/init</code>可执行文件，该进程的PID=1，进程0转化为空闲进程。<br>
<code>init进程</code>：第一个用户态的进程，由它不断调用<code>fork()</code>来创建系统里的其他进程，是所有程序的父进程，同时它也是一个守护进程。<br>
<img src="https://img-blog.csdnimg.cn/20191227162745913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
通过<code>ps -fxo user,ppid,pid,pgid,command</code>可以看到<img src="https://img-blog.csdnimg.cn/20191227162954967.png" alt="在这里插入图片描述" loading="lazy"><br>
（pid是该进程的唯一编号）（ppid是该进程的父进程的pid）（command表示该进程通过执行什么样的命令或脚本产生的）<a href="https://blog.csdn.net/nan_lei/article/details/81636473">参考网址</a></p>
<hr>
<h3 id="23进程组与sessions">2.3进程组与sessions</h3>
<ol>
<li>进程组：每一个进程都是一个进程组的成员，每一个进程组都是唯一存在的，它们依靠PGID来区别，每当一个进程被创建的时候，它便会成为其父进程所在组的一员。<br>
一般来说，该进程组的PGID等同于进程组的第一个成员的PID，该进程是这个进程组的主进程。主进程可以先终结，此时进程组仍然存在，并持有相同的PID，知道进程组中的最后一个进程结束。<br>
每一个进程组sessions中，并且这个sessions是唯一存在的。</li>
</ol>
<p>2.sessions:sessions是针对一个tty建立。sessions中的每一个进程都称为job，每一个会话可以连接一个终端。<br>
sessions 的主要作用是：将多个jobs囊括在一个终端，并取其中一个job作为前台，直接接收该终端的输入输出以及终端信号，其他job在后台运行。</p>
<hr>
<h3 id="24工作管理">2.4工作管理</h3>
<p>每个bash（终端）只能管理当前终端的job。</p>
<pre><code class="language-cpp">[job] &amp;    #&amp;让命令在后台运行

ctrl+z    #当前工作停止并转到后台

jobs     #查看停止并被放置在后台的工作

fg [%jobnumber]    #将在后台的工作拿到前台来 
#例：fg %1    #将后台job编号为1的job拿到前台来 

bg [%jobnumber]    #将job在后台运作
#例： bg %1    #将后台job编号为1的job在后台运行

kill [-信号值] [%jobnumber]     #删除或重启job
kill信号值补充：
-1： 重新读取参数运行
-2：如同ctrl+c的操作退出
-9：强制终止该任务
-15：正常的方式终止该任务
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_软件安装]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ruan-jian-an-zhuang/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ruan-jian-an-zhuang/">
        </link>
        <updated>2020-03-17T04:19:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目标">目标</h1>
<p>学习Ubuntu下软件安装的几种方式，及apt，dpkg工具的使用。</p>
<hr>
<h2 id="学习目录">学习目录</h2>
<h3 id="1apt">1.apt</h3>
<pre><code>     1.2.软件升级
     1.3.卸载软件
     1.4.软件搜索
</code></pre>
<h3 id="2dpkg">2.dpkg</h3>
<pre><code>   2.1使用dpkg安装deb软件包
   2.2查看已安装软件包的安装目录
   2.3从二进制包安装
</code></pre>
<hr>
<h3 id="1apt-2">1.apt</h3>
<p>APT是advance packaging tool （高级包装工具）的缩写，可以自动下载，配置，安装二进制或者源代码格式的软件包。<br>
<strong>安装过程</strong>：在本地数据库中搜索关于软件的相关信息→根据这些信息在相关服务器上下载软件安装。<br>
Q:为什么要在本地服务器搜索？<br>
A：我们需要定期从服务器下载一个软件包列表（<code>sudo apt-get update</code>）来保持本地的软件包列表是最新的。而这个表里会有<strong>软件依赖信息</strong>的记录。</p>
<h4 id="apt-get工具">apt-get工具</h4>
<p>1.<code>apt-get install</code>：在后面加上软件包名，<strong>用来安装一个软件包</strong>。<br>
2.<code>apt-get update</code>：从软件源镜像服务器上<strong>下载/更新</strong>用于<strong>更新本地的软件源的软件包列表</strong>。<br>
3.<code>apt-get upgrade</code>：<strong>升级本地可升级的全部安装包</strong>，但<strong>存在依赖问题</strong>时将<strong>不会升级</strong>，通常会在更新前执行一次<code>update</code>。<br>
4.<code>apt-get dist-upgrade</code>：<strong>解决依赖关系并升级</strong>（存在不确定性）。<br>
5.<code>apt-get remove</code>：<strong>移除已安装的安装包</strong>，<strong>包括与被移除软件包存在依赖关系的软件包</strong>，但<strong>不包含软件包的配置文件</strong>。<br>
6.<code>apt-get autoremove</code>：<strong>移除之前被其他安装包依赖</strong>，但<strong>现在不再使用的软件包</strong>。<br>
7.<code>apt-get purge</code>：与<code>remove</code>相同，但会<strong>完全移除软件包，包含其配置文件</strong>。<br>
8.<code>apt-get clean</code>：<strong>移除已经被下载到本地并安装的软件包</strong>。<br>
9.<code>apt-get autoclean</code>：<strong>移除已安装的软件的旧版本软件包</strong>。</p>
<h4 id="apt-get参数">apt-get参数</h4>
<p>1.<code>-f</code>：<strong>修复损坏的依赖关系</strong><br>
2.<code>-d</code>：<strong>只下载</strong>不安装<br>
3.<code>-y</code>：<strong>自动回应</strong>是否安装软件包的选项<br>
4.<code>--reinstall</code>：<strong>重新安装</strong>已安装的但可能存在问题的软件包</p>
<hr>
<h3 id="12-软件升级">1.2 软件升级</h3>
<p>实例：</p>
<pre><code class="language-cpp">sudo apt-get update    #更新软件源   
sudo apt-get upgrade    #升级没有依赖问题的软件包
sudo apt-get dist-upgrade    #升级并解决依赖关系
</code></pre>
<hr>
<h3 id="13卸载软件">1.3卸载软件</h3>
<p>实例：</p>
<pre><code class="language-cpp">sudo apt-get remove    #保留配置文件的删除
sudo apt-get purge    #不保留配置文件的删除
sudo apt-get autoremove    #移除不再需要的被以来的软件包
</code></pre>
<hr>
<h3 id="14软件搜索">1.4软件搜索</h3>
<p>实例：</p>
<pre><code class="language-cpp">sudo apt-cache search [软件名]    
#apt-cache针对本地数据进行相关操作的工具
#search [软件名] 在本地数据库中搜索软件
</code></pre>
<p><a href="https://www.debian.org/doc/manuals/apt-howto/index.zh-cn.html#contents">APT参考网址</a></p>
<hr>
<h2 id="2dpkg-2">2.dpkg</h2>
<p>使用<code>dpkg</code>从本地磁盘安装deb安装包。<br>
它可以对软件包执行打包和解包操作以及提供软件包信息。<br>
并不会自动解决依赖关系。<br>
<strong>常用参数：</strong><br>
1.<code>-i</code>：安装指定deb包。<br>
2.<code>-I</code>：显示deb包的文件的信息。<br>
3.<code>-r</code>：remove，移除已安装的软件包。<br>
4.<code>-R</code>：后面加上目录名，用于安装该目录下的所有deb安装包。<br>
5.<code>-s</code>：显示已安装软件的信息。<br>
6.<code>-S</code>：搜索已安装的软件包<br>
7.<code>-L</code>：显示已安装软件包的目录信息。</p>
<hr>
<h3 id="21使用dpkg安装deb软件包">2.1使用dpkg安装deb软件包</h3>
<p>实例：</p>
<pre><code class="language-cpp">sudo apt-get -d install -y emacs    #使用-d只下载不安装emacs编辑器
sudo dpkg -i emacs.deb[软件包名]    #这里会报错，因为dpkg不能为你解决依赖关系
sudo apt-get update    #更新源
sudo apt-get -f install -y    #使用apt-get的-f参数修复依赖关系的安装
</code></pre>
<h3 id="22查看已安装软件包的安装目录">2.2查看已安装软件包的安装目录</h3>
<p>实例：</p>
<pre><code class="language-cpp">sudo dpkg -L [软件包名]
</code></pre>
<h3 id="23从二进制包安装">2.3从二进制包安装</h3>
<p>将二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加到PATH环境变量中即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_数据提取]]></title>
        <id>https://ydPro-G.github.io/post/linux_-shu-ju-ti-qu/</id>
        <link href="https://ydPro-G.github.io/post/linux_-shu-ju-ti-qu/">
        </link>
        <updated>2020-03-17T04:18:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前提">前提</h1>
<p>有时候我们需要从文件里提取数据，当然也可能是老板甩过来一个文件让你把里面的电话和邮箱全部提取，这时候一条一条的复制粘贴总是太麻烦，这个时候我们就需要利用一些命令和正则表达式在linux系统中自动提取出来。</p>
<hr>
<h1 id="目标">目标</h1>
<p>1.提取<code>data2</code>文件中的数字开头的行，并把他们写入<code>/home/root/num</code>中。<br>
2.提取<code>data2</code>文件中的邮箱，并把他们写入<code>/home/root/mail</code>中。<br>
补充：<code>data2</code>文件目录<code>/home/root/data2</code><br>
<code>data2</code>包含内容<br>
<img src="https://img-blog.csdnimg.cn/20191225111026739.png" alt="" loading="lazy"></p>
<h1 id="实例">实例</h1>
<pre><code class="language-cpp">1.提取数字开头的行，并写入/home/root/num中
grep '^[0-9]' /home/root/data2 &gt; /home/root/num    # ^：匹配输入字符串的开始位置
                                                   # [0-9]：匹配所有数字
                                                   # &gt;：重定向
                                   
2.提取文件中的所有邮箱，并写入/home/root/amil中
grep -E '*@*\.com' /home/root/data2 &gt; /home/root/mail    # -E:扩展正则表达式
                                                         
</code></pre>
<h5 id="扩展正则表达式与正则表达式的不同它们之间的区别仅仅是元字符不同">扩展正则表达式与正则表达式的不同：它们之间的区别仅仅是元字符不同。</h5>
<h5 id="基础正则表达式bre元字符">基础正则表达式（BRE）元字符：<code>^</code>,<code>$</code>,<code>.</code>,<code>[]</code>,<code>*</code>。</h5>
<h5 id="扩展正则表达式ere元字符添加了">扩展正则表达式（ERE）元字符:添加了<code>+</code>，<code>?</code>,<code>|</code>,<code>()</code>,<code>{}</code>。</h5>
<p>元字符作用详细信息：<a href="https://www.cnblogs.com/linyfeng/p/7353693.html">参考网址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_正则表达式]]></title>
        <id>https://ydPro-G.github.io/post/linux_-zheng-ze-biao-da-shi/</id>
        <link href="https://ydPro-G.github.io/post/linux_-zheng-ze-biao-da-shi/">
        </link>
        <updated>2020-03-17T04:17:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目标">目标</h1>
<p>1.掌握基本命令：sed ,grep ,awk的用法<br>
2.掌握正则表达式符号和语法</p>
<h1 id="学习目录">学习目录</h1>
<p>1.什么是正则表达式？<br>
2.正则表达式的基本语法<br>
3.grep命令<br>
4.sed流编辑器<br>
5.awk文本处理语言</p>
<hr>
<h2 id="1什么是正则表达式">1.什么是正则表达式？</h2>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。正则表达式就是记录文本规则的代码。<br>
下面通过<code>grep，sed和awk</code>命令来实际演示正则表达式如何使用。<br>
<a href="https://www.jb51.net/tools/zhengze.html">参考网址</a></p>
<hr>
<h2 id="2正则表达式的基本语法">2.正则表达式的基本语法</h2>
<p>一个正则表达式通常被称为一个pattern，为用来描述或者匹配一系列符合某个句法规则的字符串。</p>
<h3 id="选择">选择</h3>
<p><code>|</code>:表示选择。<br>
实例： <code>boy|girl</code>可以匹配boy或girl。</p>
<h3 id="限定数量">限定数量</h3>
<p><code>+</code>:表示<code>+</code>号前面的字符必须出现至少一次或多次。<br>
实例：<code>&quot;goo+gle&quot;</code>可以匹配出<code>gooogle，goooogle</code>。</p>
<p><code>?</code>;表示<code>?</code>前面的字符最多出现一次（0次或1次）。<br>
实例：<code>&quot;colou？r&quot;</code>可以匹配<code>color，colour</code>。</p>
<p><code>*</code>:表示<code>*</code>前面的字符可以不出现也可以出现一次或多次。<br>
实例：<code>&quot;0*42&quot;</code>可以匹配<code>42,042,0042,00042</code>。</p>
<h3 id="范围和优先级">范围和优先级</h3>
<p><code>()</code>圆括号可以用来定义模式字符串的范围和优先级。</p>
<h3 id="语法">语法</h3>
<p><code>\</code>:<strong>将下一个字符标记为一个特殊字符或一个原义字符。</strong><br>
<code>^</code>:匹配<strong>输入字符串开始的位置。</strong><br>
<code>$</code>:匹配<strong>输入字符串的结束位置。</strong><br>
<code>{n}</code>:n是一个非负整数<strong>匹配确定的n次。</strong><br>
实例：<code>&quot;o{2}&quot;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code>。<br>
<code>{n,}</code>:n是一个非负整数，<strong>至少匹配n次。</strong><br>
实例：<code>&quot;o{2,}&quot;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>fooooood</code>中的所有<code>o</code>。<code>o{1,}</code>等价于<code>o+</code>。<code>o{0,}等价于o*</code>.<br>
<code>{n,m}</code>:m和n均为非负整数，其中n&lt;=m。<strong>最少匹配<code>n</code>次且最多匹配<code>m</code>次。</strong><br>
<code>*</code>:匹配前面的子表达式零次或多次。例如，<code>zo*</code>能匹配<code>“z”、“zo”以及“zoo”</code>。*等价于<code>{0,}</code><br>
<code>+</code>:匹配前面的子表达式一次或多次。<br>
<code>?</code>:匹配前面的子表达式零次或一次。<br>
<code>.</code>:匹配除<code>\n</code>之外的任何单个字符。<br>
<code>（pattern）</code>:匹配pattern并获取这一匹配的子字符串。<br>
<code>x|y</code>:匹配x或y。<br>
<code>[xyz]</code>:字符集合。匹配所包含的任一字符。<br>
<code>[^xyz]</code>:排除型字符集合。匹配未列出的任意字符。<br>
<code>[a-z]</code>:字符范围。匹配指定范围内的任意字符。<br>
<code>[^a-z]</code>:排除型字符范围。匹配任何不在指定范围内的任意字符。<br>
【思维导图】</p>
<hr>
<h2 id="3grep命令">3.grep命令</h2>
<p>grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。</p>
<h4 id="grep支持的三种正则表达式引擎">grep支持的三种正则表达式引擎</h4>
<p>1.<code>-E</code>:POSIX扩展正则表达式 ERE<br>
2.<code>-G</code>：POSIX基本正则表达式 BRE<br>
3.<code>-p</code>：perl正则表达式 PCRE<br>
<a href="https://wangchujiang.com/linux-command/c/grep.html">grep命令参考网址</a></p>
<h4 id="使用正则表达式bre">使用正则表达式BRE</h4>
<p>实例：</p>
<pre><code class="language-cpp">位置：
grep '^a' /etc/passwd  #查找/etc/passwd文件中以a开头的行

数量：
echo zero\nzo\nzoo | grep 'z.*o'   #匹配以z开头以o结尾的所有字符串。
echo zero\nzo\nzoo | grep 'z.o'    #匹配以z开头的以o结尾中间包含任一字符的字符串。
echo zero\nzo\nzoo | grep 'zo*'    #匹配以z开头以任意多个o结尾的字符串

选择：
nl /etc/passwd | grep '[a-z]'   #匹配/etc/passwd中所有的小写字母
nl /etc/passwd | grep '[0-9]'   #匹配/etc/passwd所有数字
nl /etc/passwd | grep '[[:digit:]]'   #匹配/etc/passwd所有数字
nl /etc/passwd | grep '[[:lower:]]'   #匹配/etc/passwd所有小写字母
nl /etc/passwd | grep '[[:upper:]]'   #匹配/etc/passwd所有大写字母
nl /etc/passwd | grep '[[:alnum:]]'   #匹配/etc/passwd所有字母和数字
nl /etc/passwd | grep '[[:alpha:]]'   #匹配/etc/passwd所有字母

排除字符
echo 'geek\ngood' | grep '[^o]'    #当^放入[]代表排除字符，o不显示
</code></pre>
<h4 id="使用扩展正则表达式ere">使用扩展正则表达式ERE</h4>
<p>要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。<br>
实例：</p>
<pre><code class="language-cpp">数量：
nl /etc/passwd | grep -E 'zo{1}'    #只匹配zo
echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'    #匹配以zo开头的所有单词  

选择：
echo 'www.baidu.com\nwww.google.com\nwww.bing.com' | grep -E 'www\.(google|bing)\.com'   
#匹配www.google.com和www.bing.com
echo 'www.baidu.com\nwww.google.com\nwww.bing.com' | grep -Ev 'www\.baidu\.com'
#匹配不包含www.baidu.com的内容
PS：.号有特殊含义，需要\转义符来转义
</code></pre>
<hr>
<h2 id="4sed流编辑器">4.sed流编辑器</h2>
<p>功能强大的流式文本编辑器。<br>
sed 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<h3 id="sed基本格式">sed基本格式</h3>
<p><code>sed [参数]... [执行命令][输入文件]...</code><br>
<a href="https://wangchujiang.com/linux-command/c/sed.html">sed命令参考网址</a></p>
<h4 id="sed动作指令">sed动作指令</h4>
<p><code>s</code>:行内替换<br>
<code>c</code>:整行替换<br>
<code>a</code>:插到指定行的后面<br>
<code>i</code>:插到指定行的前面<br>
<code>p</code>:打印指定行，通常与<code>-n</code>参数配合使用<br>
<code>d</code>:删除指定行<br>
实例：</p>
<pre><code class="language-cpp">打印指定行（p）:
nl passwd（文件） | sed -n '2,5p'    #打印2-5行
nl passwd（文件） | sed -n '1~2p'    #打印奇数行

行内替换（s）：
sed -n 's/zsh/hehe/gp' passwd(文件)
#将输入文本中zsh全局替换为hehe，并且只打印替换的那一行

删除某行（d）:
sed -i '30d' passwd(文件)    #删除30行
</code></pre>
<hr>
<h2 id="5awk文本处理语言">5.awk文本处理语言</h2>
<p>文本和数据进行处理的编程语言。<br>
awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。<br>
操作基于<code>pattern {action}</code>完成。<br>
实例：</p>
<pre><code class="language-cpp">准备：
vim test    #使用vim新建一个文本文档
I like Linux 
www.github.com    #输入以上内容

将文本内容打印到终端
1.
awk '{
print
}' test
2.
awk '{print}' test    #可以写多行也可以写一行

将test第一行的每个字段单独显示为一行
awk '{
if(NR==1){
print $1 &quot;\n&quot; $2 &quot;\n&quot; $3 &quot;\n&quot;
} else {
print}
}' test    #NR是awk内建的变量，表示当前处理的行数。 $n中的n为相应的字段号
或者
awk '{
if(NR==1){
OFS=&quot;\n&quot;
print $1,$2,$3
} else {
print}
}' test    #OFS是awk内建的变量，表示输出时的字段分隔符，默认为空格。    

将test的第二行以点分布的字段换成以空格为分隔
awk -F'.' '{
if(NR==2){
print $1 &quot;\t&quot; $2 &quot;\t&quot; $3 &quot;\t&quot;    #print打印的非变量内容都需要用&quot;&quot;包围起来
}}' test    #-F用来预先指定待处理记录的字段分隔符
或者
awk '
BEGIN{    #BEGIN这个表达式指示了其后的动作将在所有动作之前执行。
FS=&quot;.&quot;
OFS=&quot;\t&quot;
}{
if(NR==2){
print $1,$2,$3
}}' test    
</code></pre>
<p><a href="https://coolshell.cn/articles/9070.html">参考网址1</a><br>
<a href="https://awk.readthedocs.io/en/latest/chapter-one.html">参考网址2</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_查看历史数据/命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-cha-kan-li-shi-shu-ju-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-cha-kan-li-shi-shu-ju-ming-ling/">
        </link>
        <updated>2020-03-17T04:16:48.000Z</updated>
        <content type="html"><![CDATA[<p>在linux中，对于文本的处理和分析是极为重要的，现在有一个文件（file1）里面记载了一些数据，现在请你找出这个文件（file1）中出现频率前三的数据并保存在<code>/home/directory</code>中。</p>
<h1 id="目标">目标</h1>
<ol>
<li>处理文本文件<code>file1</code></li>
<li>结果包含三行内容，每行的内容都包含命令出现的次数和命令名称</li>
<li>将结果输入到<code>/home/directory</code>中</li>
</ol>
<h2 id="目标分析">目标分析</h2>
<p>注意使用管道<code>|</code></p>
<ol start="4">
<li>首先要查看文件内容<code>cat</code></li>
<li>将不相关的数据剔除掉<code>cut</code></li>
<li>将命令排序<code>sort</code></li>
<li>去掉重复命令并显示行数<code>uniq</code></li>
<li>将命令重新排序，<code>sort</code>让它用数字排序（<code>n</code>），大的数字显示在上面<code>r</code>,然后指定按照第一列的数字排序(<code>-k1</code>)</li>
<li>只显示文件开头前三行部分（<code>head</code>）</li>
<li>将命令重定向到<code>directory</code>中</li>
</ol>
<h3 id="命令">命令</h3>
<pre><code class="language-cpp">cat file1 | cut -c 8- | sort | uniq -dc | sort -nr -k1 | head -3 &gt; /home/directory
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_数据流重定向]]></title>
        <id>https://ydPro-G.github.io/post/linux_-shu-ju-liu-chong-ding-xiang/</id>
        <link href="https://ydPro-G.github.io/post/linux_-shu-ju-liu-chong-ding-xiang/">
        </link>
        <updated>2020-03-17T04:15:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目的">目的</h1>
<p>1.重定向怎么用<br>
2.文件描述符(0,1,2)</p>
<h2 id="学习目录">学习目录</h2>
<ol>
<li>数据流重定向</li>
<li>简单的重定向</li>
<li>标准错误的重定向</li>
<li>使用<code>tee</code>命令重定向到多个文件</li>
<li>exec命令</li>
<li>创建文件描述符</li>
<li>关闭文件描述符</li>
<li>完全屏蔽命令的输出</li>
<li>使用xargs分割参数列表</li>
</ol>
<hr>
<h3 id="1数据流重定向">1.数据流重定向</h3>
<h4 id="命令">命令</h4>
<p><code>&gt;</code> : 覆盖文件内容并写入<br>
<code>&gt;&gt;</code>：在文件后面追加，不覆盖文件内容<br>
<code>&lt;</code>：和<code>&gt;</code>作用一样，表示从右到左<br>
<code>&lt;&lt;</code>:和<code>&gt;&gt;</code>作用一样，表示从右到左</p>
<hr>
<h3 id="2简单的重定向">2.简单的重定向</h3>
<h4 id="前置知识文件描述符">前置知识：文件描述符</h4>
<pre><code class="language-bash"> 1.  文件描述符：0   设备文件：/dev/stdin    缩写：stdin    说明：标准输入
 2.  文件描述符：1   设备文件：/dev/stdout   缩写：stdout   说明：标准输出
 3.  文件描述符：2   设备文件：/dev/stderr   缩写：stderr   说明：标准错误
</code></pre>
<p><a href="https://blog.csdn.net/xlinsist/article/details/51147212">参考网址</a></p>
<p>实例（1：</p>
<pre><code class="language-bash">mkdir Documents #创建目录
cat &gt; Documents/test.c &lt;&lt; EOF   #将cat的连续输出重定向到一个文件中
#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;hello world/n&quot;);
    return 0;
}
EOF
</code></pre>
<p>补充<code>EOF</code>：<br>
是END Of File的缩写,表示自定义终止符.既然自定义,那么EOF就不是固定的,可以随意设置别名,在linux按ctrl-d就代表EOF.<br>
EOF一般会配合cat能够多行文本输出.<br>
其用法如下:<br>
&lt;&lt;EOF        //开始<br>
....<br>
EOF            //结束<br>
<a href="https://www.cnblogs.com/xiaojianblogs/p/6486902.html">参考网址</a></p>
<p><code>cat Documents/test.c</code></p>
<p>意义：将一个文件作为命令的输入（cat），标准输出作为命令的输出</p>
<p>实例（2：</p>
<pre><code class="language-cpp"> #将echo命令的输出从默认的标准输出重定向到一个普通文件
echo 'hello world' &gt; file 
#查看文件
cat file  
</code></pre>
<hr>
<h3 id="3标准错误的重定向">3.标准错误的重定向</h3>
<p>实例（1：</p>
<pre><code class="language-cpp"> #用bash提供的特殊的重定向符号“&amp;”将标准错误和标准输出同时重定向到文件
 cat [目录]/[标准输出文件] [标准错误文件] &amp;&gt; [文件] 
</code></pre>
<p>实例（2：</p>
<pre><code class="language-cpp">#将标准错误重定向到标准输出，将标准输出重定向到文件中，注意要将标准输出重定向到文件写在前面
cat [目录]/[标准输出文件] [标准错误文件] &gt; [文件] 2&gt;&amp;1 
</code></pre>
<p>补充：在输出重定向文件描述符前加上<code>&amp;</code>，否则shell会当作重定向到一个文件名为1的文件中</p>
<hr>
<h3 id="4使用tee命令同时重定向到多个文件">4.使用tee命令同时重定向到多个文件</h3>
<p>实例（1：</p>
<pre><code class="language-cpp">#将echo命令输出通过tee命令同时重定向到file1 file2 file3
echo 'git is good' | tee file1 file2 file3  
</code></pre>
<hr>
<h3 id="5exec命令">5.exec命令</h3>
<p>调用并执行指定的命令。<br>
exec命令 用于调用并执行指令的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。</p>
<p>实例（1：</p>
<pre><code class="language-cpp">zsh #进入子shell
exec 1 &gt; somefile   #使用exec替换当前进程的重定向，将标准输出（1）重定向到文件中
#后面执行的命令都将重定向到文件中，知道使用exit退出当前子shell
ls            #ls命令重定向到文件（somefile）中
ll            #ll命令重定向到文件（somefile）中
pwd           #pwd命令重定向到文件（somefile）中
exit          #退出
cat somefile    #主进程查看文件（somefile）  ls ll  pwd命令会同时执行
</code></pre>
<p><a href="https://blog.csdn.net/yanggd1987/article/details/38926901">参考网址</a></p>
<h3 id="6创建文件描述符">6.创建文件描述符</h3>
<p>Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象。其实我们可以想象我们电脑的显示器和键盘在Linux系统中都被看作是文件，而它们都有相应的文件描述符与之对应。<br>
shell中有9个文件描述符，上面是用了它提供的默认的0,1,2文件描述符，另外我们还可以使用3—8文件描述符。</p>
<p><code>cat /dev/fd;ls -Al</code>:查看当前shell进程中打开的文件描述符。<br>
<code>;</code>:路径的分隔符</p>
<p>实例（1：</p>
<pre><code class="language-cpp">zsh #进入子shell
exec 3 &gt; somefile           #将文件描述符3重定向到文件中（somefile）
cat /dev/fd;ls -Al;cd -     #查看当前shell中打开的文件描述符
echo &quot;this is test&quot; &gt;&amp;3           #将echo命令的输出重定向到文件描述符3种
cat somefile           #查看文件（somefile）
exit           #退出
</code></pre>
<p><a href="https://blog.csdn.net/xlinsist/article/details/51147212">参考网址</a></p>
<hr>
<h3 id="7关闭文件描述符">7.关闭文件描述符</h3>
<p><code>exec 3&gt;&amp;-</code>:关闭文件描述符3</p>
<hr>
<h3 id="8完全屏蔽命令的输出">8.完全屏蔽命令的输出</h3>
<h4 id="前置知识">前置知识</h4>
<p><code>/dev/null</code>空设备，一般用来丢弃不需要的输出流</p>
<p>实例（1：</p>
<pre><code class="language-cpp">cat directory/file 1&gt;/dev/null 2&gt;&amp;1    
#将文件标准输出（1）重定向到/dev/null中，将标准错误（2）重定向到标准输出（1）中
</code></pre>
<p>补充：<br>
<code>cat</code>：连接多个文件并打印到标准输出</p>
<hr>
<h3 id="9使用xargs分割参数列表">9.使用xargs分割参数列表</h3>
<p>将列表参数转换成小块分段传递给其他命令，以避免参数列表过长问题。</p>
<p>实例（1：</p>
<pre><code class="language-cpp">cut -d: -f1 &lt; /etc/passwd | sort |xargs echo
 #将/etc/passwd文件按：分割，取第一个字段排序后，使用echo命令生成一个列表。
</code></pre>
<p><a href="https://wangchujiang.com/linux-command/c/xargs.html">参考网址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_简单的文本处理]]></title>
        <id>https://ydPro-G.github.io/post/linux_-jian-dan-de-wen-ben-chu-li/</id>
        <link href="https://ydPro-G.github.io/post/linux_-jian-dan-de-wen-ben-chu-li/">
        </link>
        <updated>2020-03-17T04:14:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目的">目的</h1>
<p>1.常见文本处理命令<br>
2.如何简单处理文本</p>
<h3 id="学习目录">学习目录</h3>
<ol>
<li>tr</li>
<li>col</li>
<li>join</li>
<li>paste</li>
</ol>
<hr>
<h3 id="1tr命令">1.tr命令</h3>
<p>将字符进行替换压缩和删除<br>
tr命令 可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。</p>
<p>实例：<code>echo 'hello world' | tr -d 'ol'</code><br>
意义：删除<strong>hello world</strong>中所有的<strong>ol</strong></p>
<p>实例：<code>echo 'hello world' | tr -s &quot;l&quot;</code><br>
将<strong>hello world</strong>中的<strong>l</strong>去重为一个<strong>l</strong></p>
<p>实例：<code>echo 'hello' | tr '[a-z]' '[A-Z]'</code><br>
：<code>echo 'HELLO | tr '[A-Z] '[a-z]'</code><br>
意义：将hello转换成HELLO<br>
将HELLO转换成hello<br>
<strong>大小写转换</strong><br>
<a href="https://wangchujiang.com/linux-command/c/tr.html">参考网址</a></p>
<hr>
<h3 id="2col命令">2.col命令</h3>
<p>过滤控制字符，<strong>col 命令可以将Tab换成对等数量的空格键，或反转这个操作。</strong><br>
col命令 是一个标准输入文本过滤器，它从标注输入设备读取文本内容，并把内容显示到标注输出设备。在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符&gt;和&gt;&gt;，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col命令则能有效滤除这些控制字符。</p>
<p>实例：<code>cat [目录/文件] | col -x | cat -A</code>:<br>
意义：使用<code>col -x</code>将相应目录的相关文件中的<code>tab</code>字符转换成<code>空格</code>，然后使用<code>cat -A</code>查看<br>
<code>cat -A</code>查看不可见字符<br>
<a href="https://wangchujiang.com/linux-command/c/col.html">参考网址</a></p>
<hr>
<h3 id="3join命令">3.join命令</h3>
<p>两个文件中<strong>指定栏位内容相同的行连接</strong>起来<br>
join命令 用来将<strong>两个文件</strong>中，<strong>指定栏位内容相同的行连接起来</strong>。找出两个文件中，指定栏位内容相同的行，并加以合并，再<strong>输出到标准输出设备</strong>。</p>
<p>实例：<br>
<code>&gt;</code>:覆盖文件内容并写入<br>
<code>&gt;&gt;</code>:在文件后面追加，不覆盖<br>
<code>echo '1 hello' &gt; file1</code>:输入1 hello并覆盖文件内容写入file1文件中<br>
<code>echo '1 world' &gt; file2</code>:输入1 world并覆盖文件内容写入到file2文件中<br>
<code>join file1 file2</code>:输出<code>1 hello world</code>将<code>file1</code>和<code>file2</code>文件中包含相同内容（<code>1</code>）的那一行合并在一起。</p>
<p>实例：<code>sudo join -t':' /etc/passwd[目录/文件] /etc/shadow[目录/文件]</code>:<br>
意义：将两个文件合并，并指定以<code>':'</code>为分隔符<br>
<code>-t</code>：指定分隔符，默认为空格</p>
<p>实例：<code>sudo join -t':' -1 1 [目录/文件] -2 1 [目录/文件]</code><br>
意义：将2个文件合并，指定以<code>':'</code>作为分隔符，并对比第一字段和第二字段<br>
<code>-1</code>:指明第一个文件要用哪个字段来对比，默认是第一个字段<br>
<code>-2</code>:指明第二个文件要用哪个字段来对比，默认是第一个字段<br>
<a href="https://wangchujiang.com/linux-command/c/join.html">参考网址</a></p>
<h3 id="4paste命令">4.paste命令</h3>
<p>将多个文件按列队列合并<br>
paste命令 用于将多个文件按照列队列进行合并。</p>
<p>实例：<code>paste -d ':' [文件] [文件] [文件]</code><br>
意义：将三个文件合并在一起，<code>-d</code>指定分隔符为<code>':'</code>,默认为TAB</p>
<p>实例<code>paste -s [文件] [文件] [文件]</code><br>
意义：将三个文件合并在一起，<code>-s</code>不合并到一行，每个文件为一行。<br>
<a href="https://wangchujiang.com/linux-command/c/paste.html">参考网址</a></p>
<h2 id="复习">复习</h2>
<p>手动完成 dos 文本格式到 UNIX 文本格式的转换。</p>
<pre><code class="language-bash">echo hello &gt; file1
cat -A file1 |  tr '$' '\r\n' &gt; file2; cat -A file2
</code></pre>
<p>将unix文本转换成dos文本</p>
<pre><code class="language-bash">cat -A file2 | tr -d '^M$' &gt; file3; cat -A file3
</code></pre>
<p>将dos文本转换成unix文本</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_常用命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-chang-yong-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-chang-yong-ming-ling/">
        </link>
        <updated>2020-03-17T04:13:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>学习linux系统上的常用命令。</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>cut</li>
<li>grep</li>
<li>wc</li>
<li>sort</li>
<li>uniq</li>
</ol>
<h2 id="1cut命令">1.cut命令</h2>
<p>连接文件并打印到标准输出设备上</p>
<p>实例： <code>cut /etc/passwd -d '：' -f 1,6</code>:<br>
意义： 打印<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第1字段和第6字段。</p>
<p>实例：打印<code>etc/passwd</code>中指定的字段<br>
<code>cut /etc/passwd -c -7</code>:打印前七个字段（包含第七个）<br>
<code>cut /etc/passwd -c 7-</code>:打印前七个字段之后的字段（包含第七个）<br>
<code>cut /etc/passwd -c 7</code>:打印第七个字段<br>
<code>cut /etc/passwd -c 1-7</code>:打印1-7字段（包含第七个）<br>
<a href="https://wangchujiang.com/linux-command/c/cut.html">参考文章</a></p>
<hr>
<h3 id="2grep命令">2.grep命令</h3>
<p>强大的文本搜索工具，能够使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤搜索的特定字符。<br>
命令的一般形式：<code>grep [命令选项] &quot;[文件&quot;] 目录</code></p>
<p>实例：<code>grep -rnI &quot;vim&quot; ~（目录）</code>:<br>
意义：搜索当前目录下所有带有<code>vim</code> 的文本文件。并显示出现在文本中的行号。<br>
<code>r</code>:表示递归搜索子目录中的文件<br>
<code>n</code>：表示打印匹配行项行号<br>
<code>I</code>：表示忽略二进制文件</p>
<p>实例：<code>export | grep “.*a$”</code>:<br>
意义：查看环境变量中以<code>“a”</code>结尾的字符串<br>
<code>export</code>：为shell变量或函数设置导出属性<br>
<code>|</code>:管道<br>
<code>*</code>:所有<br>
<code>$</code>:表示一行的末尾，去掉就是搜索所有<br>
<a href="https://wangchujiang.com/linux-command/c/grep.html#!kw=export">参考文章</a></p>
<hr>
<h3 id="3wc命令">3.wc命令</h3>
<p>统计文件的字节数、字数、行数。</p>
<p>实例：<br>
<code>wc /etc/passwd</code>：输出<code>passwd</code>文件统计信息<br>
<code>wc -l /etc/passwd</code>:输出<code>passwd</code>文件行数<br>
<code>wc -w /etc/passwd</code>:输出<code>passwd</code>文件单词数<br>
<code>wc -c /etc/passwd</code>:输出<code>passwd</code>文件字节数<br>
<code>wc -m /etc/passwd</code>:输出<code>passwd</code>文件字符数<br>
<code>wc -L /etc/passwd</code>:输出<code>passwd</code>文件最长行字节数</p>
<p>结合<strong>管道</strong>文件实际运用：<br>
任务：统计<code>/etc</code>目录下面所有的目录数<br>
<code>ls -dl /etc/*/ | wc -l</code><br>
<a href="https://wangchujiang.com/linux-command/c/wc.html">参考文章</a></p>
<hr>
<h3 id="4sort命令">4.sort命令</h3>
<p>将文件进行排序并输出。</p>
<p><code>cat /etc/passwd | sort</code>:默认字典排序<br>
<code>cat /etc/passwd | sort -r</code>:反转排序</p>
<pre><code>cat /etc/passwd | sort -t `:` -k 3 -n
</code></pre>
<p>按特定字段排序<br>
<code>-t</code>：指定字段的分隔符<br>
<code>-k 3</code>：用于对哪一个字段进行排序<br>
<code>-n</code>：按照数字排序就要加上<code>-n</code> 参数<br>
<a href="https://wangchujiang.com/linux-command/c/sort.html">参考文章</a></p>
<hr>
<h3 id="uniq命令">uniq命令</h3>
<p>报告或忽略文件中的重复行</p>
<p>实例：<br>
<code>history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq</code><br>
意义：使用<code>history</code>命令查看最近执行过的命令，<code>cut</code>去掉命令后面的参数，然后用<code>sort</code>排序，最后用<code>uniq</code>全文去重。<br>
<code>uniq -dc</code>：输出重复过的行及重复次数<br>
<code>uniq -D</code>：输出所有重复的行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_管道]]></title>
        <id>https://ydPro-G.github.io/post/linux_-guan-dao/</id>
        <link href="https://ydPro-G.github.io/post/linux_-guan-dao/">
        </link>
        <updated>2020-03-17T04:10:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习目录">学习目录</h1>
<p>管道以文件形式存在<br>
<code>|</code></p>
<h2 id="命令">命令</h2>
<h3 id="1匿名管道">1.匿名管道：<code>|</code></h3>
<p>特点：只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样，子进程通过通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。<br>
<strong>优点</strong>：保证了传输数据的安全性。<br>
<strong>缺点</strong>：降低了管道通用性。</p>
<h3 id="2命名管道mkfifomknod">2.命名管道：<code>mkfifo</code>，<code>mknod</code></h3>
<p>实例：<code>mkfifo [管道名]</code>：有了这个管道文件，系统就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件通信了。<br>
<a href="https://zhuanlan.zhihu.com/p/58489873">参考文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_命令执行顺序]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ming-ling-zhi-xing-shun-xu/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ming-ling-zhi-xing-shun-xu/">
        </link>
        <updated>2020-03-17T04:08:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前提">前提：</h1>
<p>通常情况下，我们会在终端输入一条命令再输入下一条命令，可是如果我们想要一次性输入多个命令呢？</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>顺序执行多条命令</li>
<li>有选择的执行命令<br>
<code>&amp;&amp;</code><br>
<code>||</code></li>
</ol>
<h2 id="命令及实例">命令及实例</h2>
<h3 id="1顺序执行多条命令">1顺序执行多条命令</h3>
<p><code>sudo apt-get update</code>:更新源<br>
<code>sudo apt-get install [软件]</code>:下载具体的软件<br>
<code>[运行软件]</code>：运行具体的软件</p>
<p>如果想要<strong>一次性输完所有命令</strong>，让他们<strong>依次去执行</strong>可以用<code>;</code>来完成。</p>
<pre><code>sudo apt-get update;sudo apt-get install [软件];[软件]
</code></pre>
<hr>
<h1 id="2有选择的执行命令">2.有选择的执行命令</h1>
<h1 id="学习目录-2">学习目录</h1>
<p><code>&amp;&amp;</code><br>
<code>||</code></p>
<p>如果自动执行命令时，前面的命令不能执行，而后面的命令又依赖于上一条命令的结果，那么就会造成错误，这种情况下我们就<strong>需要有一个判断公式</strong>来判断上一条命令执行成功后再执行下一条命令，或者不成功我们又该做出其他的处理。</p>
<h4 id="实例">实例：</h4>
<pre><code>which cowsay&gt;/dev/null &amp;&amp; coway -f head-in ohch~
</code></pre>
<p>程序含义：<br>
<code>whoch cowsay&gt;/dev/null</code>:查询<code>cowsay[文件]</code>是否在目录<code>/dev/null</code>中。<br>
<code>&amp;&amp;</code>：用来实现选择性执行，如果前面的命令执行状态的结果返回0（即查询到）就执行后面，否则就不执行。<br>
<code>cowsay -f head-in ohch~</code>：<code>cowsay</code>【牛】在<code>-f head-in</code>头部聊天框中显示ohch~</p>
<h5 id="补充">补充</h5>
<p><code>||</code>在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令。</p>
<h3 id="如何得知命令执行状态的返回结果是否为0或1">如何得知命令执行状态的返回结果是否为0或1？</h3>
<p>先查询这个文件<br>
<code>which [文件]</code><br>
然后可以从<code>&amp;</code>环境变量中获取上一次命令的返回结果<br>
<code>echo $?</code></p>
<h3 id="也可以结合着和来实现一些操作">也可以结合着&amp;&amp;和||来实现一些操作</h3>
<p>实例：<br>
<code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist || echo &quot;not exist&quot;</code><br>
流程图<br>
<img src="https://img-blog.csdnimg.cn/20191214112718759.png" alt="l流程图" loading="lazy"></p>
<h4 id="将和反过来行不行">将<code>&amp;&amp;</code>和<code>||</code>反过来行不行？</h4>
<p>将<code>&amp;&amp;</code>和<code>||</code>反过来结果不一样<br>
<code>which cowsay&gt;/dev/null || echo &quot;exist &amp;&amp; echo &quot;not exist&quot;</code><br>
输出<code>not exist</code> <code>exist</code>两个都输出<br>
为什么？<br>
<code>which cowsay&gt;/dev/null</code>的结果不是0,所以<code>||</code>后面的语句会被执行,而且,<code>||</code>之后的语句成功执行之后,<code>#?</code>的值因为成功执行了<code>||</code>后面的语句变成了0,所以<code>&amp;&amp;</code>后面的语句执行了。</p>
]]></content>
    </entry>
</feed>