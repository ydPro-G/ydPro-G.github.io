<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ydPro-G.github.io/</id>
    <title>ydPro Blog</title>
    <updated>2020-03-17T04:08:27.754Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ydPro-G.github.io/"/>
    <link rel="self" href="https://ydPro-G.github.io/atom.xml"/>
    <subtitle>Life &amp; Work</subtitle>
    <logo>https://ydPro-G.github.io/images/avatar.png</logo>
    <icon>https://ydPro-G.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ydPro Blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux_备份日志]]></title>
        <id>https://ydPro-G.github.io/post/linux_-bei-fen-ri-zhi/</id>
        <link href="https://ydPro-G.github.io/post/linux_-bei-fen-ri-zhi/">
        </link>
        <updated>2020-03-17T04:07:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="备份日志">备份日志</h1>
<p>要求:<br>
他需要每天备份论坛数据（这里我们用 alternatives.log 日志），备份当天的日志并删除之前的日志。而且备份之后文件名是 年-月-日 的格式。alternatives.log 在 /var/log/ 下面。<br>
1.为 shiyanlou 用户添加计划任务<br>
2.每天凌晨 3 点的时候定时备份 alternatives.log 到 /home/world/tmp/ 目录<br>
3.命名格式为 年-月-日，比如今天是2017年4月1日，那么文件名为 2017-04-01</p>
<p>解答：<br>
1.进入crontab -e 添加<br>
2.在3点将/home/world/tmp/所有文件清零<br>
3.在3点将在/var/log目录下的alternatives.log文件<code>CP</code>到 /home/world/tmp文件中,然后以年-月-日命名文件</p>
<pre><code>1.
crontab -e
choose vim
# 添加例行性工作排程
2.
0 3 * * * sudo rm /home/world/tmp/*
#清零
3.
0 3 * * * sudo cp /var/log/alternatives.log /home/wrold/tmp/$(date +$/%Y-/%m-/%d)
cp文件并重命名
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_例行性工作排程]]></title>
        <id>https://ydPro-G.github.io/post/linux_-li-xing-xing-gong-zuo-pai-cheng/</id>
        <link href="https://ydPro-G.github.io/post/linux_-li-xing-xing-gong-zuo-pai-cheng/">
        </link>
        <updated>2020-03-17T03:43:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是例行性工作排程">什么是例行性工作排程？</h1>
<p>1.有的工作是例行性的，比如吃饭<br>
2.有的工作是临时发生的，比如请别人吃饭<br>
<code>at</code>：at是个可以处理仅执行一次就结束排程的指令，不过要执行at时，必须要有atd这个服务的支援才行。<br>
<code>crontab</code>：crontab这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab除了可以使用指令执行外，亦可编辑/etc/crontab来支援。</p>
<h1 id="学习目录">学习目录</h1>
<p><code>crontab</code>的使用</p>
<h2 id="语法">语法</h2>
<p><code>corntab</code>(选项)（参数）<br>
<img src="https://ydPro-G.github.io//post-images/1584416805307.png" alt="" loading="lazy"></p>
<h2 id="选项">选项</h2>
<pre><code>-e：编辑该用户的计时器设置；
-l：列出该用户的计时器设置；
-r：删除该用户的计时器设置；
-u&lt;用户名称&gt;：指定要设定计时器的用户名称。
</code></pre>
<h2 id="命令">命令</h2>
<p><code>crontab -e</code>:编辑用户的计时器设置</p>
<h2 id="系统级别的定时任务">系统级别的定时任务</h2>
<p>用<code>sudo</code>的权限编辑<code>/etc/crontab</code></p>
<p>参考：<a href="http://linux.vbird.org/linux_basic/0430cron.php">Linux例行性工作排程——Linux鸟哥的私房菜</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_磁盘管理]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ci-pan-guan-li/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ci-pan-guan-li/">
        </link>
        <updated>2020-03-17T03:40:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习目录">学习目录</h1>
<ol>
<li>基本操作</li>
<li>简单的磁盘管理</li>
</ol>
<h2 id="基本操作">基本操作</h2>
<p><code>df -h</code>:查看主机磁盘的使用情况。<br>
<img src="https://ydPro-G.github.io//post-images/1584416473896.png" alt="" loading="lazy"><br>
物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。<br>
<code>du -h</code>查看目录的容量<br>
<code>du -h -d 0 ~</code>只查看一级目录信息<br>
<code>du -h -d 1 ~</code>只查看二级目录信息<br>
<code>-d</code>:指定查看目录的深度<br>
<code>-a</code>：显示目录中所有文件的大小<br>
<code>-s</code>;仅显示总计</p>
<h2 id="简单磁盘操作">简单磁盘操作</h2>
<p>dd也可以用在<strong>备份硬件的引导扇区</strong>、获取<strong>一定数量的随机数据或者空数据</strong>等任务中。dd程序也可以在<strong>复制时处理数据</strong>，例如<strong>转换字节序</strong>、或在 <strong>ASCII 与 EBCDIC 编码间互换</strong>。</p>
<p>dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为<strong>选项=值</strong>，而不是更标准的**--选项 值<strong>或-<strong>选项=值</strong>。dd默认从</strong>标准输入中读取**，并<strong>写入到标准输出中</strong>，但可以<strong>用选项if（input file</strong>，<strong>输入文件</strong>）和<strong>of（output file</strong>，<strong>输出文件</strong>）改变。</p>
<h3 id="1从标准输入读取用户输入输入到标准输出或文件中">1.从标准输入读取用户输入，输入到标准输出或文件中</h3>
<p><code>dd of=test bs=10 count=1</code>:从标准输入中读取用户的输入，然后输入到标准输出中或一个文件中。<br>
<code>of=test</code>:<code>of</code>定义输出，<code>test</code>为输出到的文件名。<br>
<code>bs=10</code>:<code>bs(block size)</code>指定块大小（单位默认为Byte，也可指定K，M，G单位<code>bs=1M</code>）,<code>10</code>只读取10字节的数据。<br>
<code>count=1</code>:指定块数量,<code>1</code>只有1块<br>
<strong>注意：</strong><br>
<strong>空格回车</strong>也算一字节。</p>
<h3 id="2dd命令在拷贝的同时实现数据转换例大小写转换">2.dd命令在拷贝的同时实现数据转换（例：大小写转换）</h3>
<p><code>dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</code>:将标准输入中的小写字母转换成大写字母<br>
<code>/dev/stdin</code>:dev/stdin      fd/0            symbolic        stdin(标准输入)文件描述<br>
参考链接：<a href="https://blog.csdn.net/sinat_36184075/article/details/71598834">设备文件dev详解</a><br>
<code>conv=ucare</code>:将小写字母转换成大写字母</p>
<h3 id="3使用dd命令创建虚拟镜像文件">3.使用dd命令创建虚拟镜像文件</h3>
<p><code>dd if=/dev/zero of=virtual.img bs=1M count=256</code>:从/dev/zero设备创建一个容量为256M的空文件。<br>
<code>sudo mkfs.ext4 virtual.img</code>：将虚拟磁盘镜像格式化为ext4文件系统。<br>
<code>mount -o loop -t ext4 virtual.img /mnt</code>:将创建额虚拟磁盘镜像挂在在/mnt目录<br>
<code>mount -o loop --ro virtual.img /mnt</code>:以只读的方式挂载<br>
<code>sudo umount /mnt</code>:使用umount命令卸载已挂载磁盘</p>
<h3 id="4磁盘分区">4.磁盘分区</h3>
<p><code>sudo fdisk -l</code>查看硬盘分区表信息<br>
<code>sudo fdisk virtual.img</code>；进入磁盘分区模式<br>
<code>sudo losetuo /dev/loopO virtual.img</code>:使用losetup命令建立镜像与回环设备的关联<br>
<code>sudo losetup -d /dev/loopO</code>:解除设备关联</p>
<p>之后是使用<code>mkfs</code>格式化各分区，不过格式化前，我们还要为各分区建立虚拟设备的映射，用到kpartx工具，需要先安装<br>
<code>sudo apt-get install kpartx</code><br>
<code>sudp kpartx -av /dev/loopO</code><br>
取消映射：<br>
<code>sudo kpartx -dv /dev/loopO</code><br>
全部格式化为ext4：<br>
<code>sudo mkfs.ext4 -q /dev/mapper/loopOp1</code><br>
<code>sudo mkfs.ext4 -q /dev/mapper/loopOp5</code><br>
<code>sudo mkfs.ext4 -q /dev/mapper/loopOp6</code><br>
格式化完成后在<code>/media</code>目录下新建四个空目录用于挂载虚拟磁盘：<br>
<code>mkdir -p /media/virtualdisk_{1..3}</code><br>
挂载磁盘分区：<br>
<code>sudo mount /dev/mapper/loopOp1 /media/virtualdisk_1</code><br>
<code>sudo mount /dev/mapper/loopOp5 /media/virtualdisk_2</code><br>
<code>sudo mount /dev/mapper/loopOp6 /media/virtualdisk_3</code><br>
卸载磁盘分区：<br>
<code>sudo umount /dev/mapper/loopOp1</code><br>
<code>sudo umount /dev/mapper/loopOp5</code><br>
<code>sudo umount /dev/mapper/loopOp6</code></p>
<p>如何找到当前目录下占用最大的前十个文件：<br>
<code>du -hsx * | sort -rh | head -10</code><br>
<code>du -hsx</code>:显示每个文件和目录的磁盘使用空间<br>
<code>-h</code>或--human-readable 以K，M，G为单位，提高信息的可读性。<br>
<code>-s</code>或--summarize 仅显示总计，只列出最后加总的值。<br>
<code>-x</code>或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</p>
<p><code>sort -rh</code>:将文件进行排序并输出<br>
<code>-r</code>：以相反的顺序来排序；</p>
<p><code>head -10</code>:显示文件的开头部分。<br>
<code>-10</code>:显示前十个</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_压缩&打包&解压缩]]></title>
        <id>https://ydPro-G.github.io/post/linux_-ya-suo-andda-bao-andjie-ya-suo/</id>
        <link href="https://ydPro-G.github.io/post/linux_-ya-suo-andda-bao-andjie-ya-suo/">
        </link>
        <updated>2020-03-17T03:38:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>Linux上常用的压缩/解压工具，主要是zip，tar的使用。</p>
<h1 id="学习目录">学习目录</h1>
<ol>
<li>zip命令</li>
<li>tar命令</li>
<li>压缩与解压常用组合</li>
</ol>
<h1 id="关键指令">关键指令</h1>
<p>1.zip：</p>
<ul>
<li>打包命令：zip something.zip something (目录加 -r 参数)</li>
<li>解包命令：unzip something.zip (指定解压路径加 -d 参数)</li>
</ul>
<hr>
<p>2.tar</p>
<ul>
<li>打包命令：tar -cf something.tar something</li>
<li>解压命令：tar -xf something.tar (指定路径 -C 参数)</li>
</ul>
<h2 id="1zip命令">1.zip命令</h2>
<p>命令：<br>
<code>zip -r -1 -l -e -q -o [文件名].zip [目录/文件]</code>：用zip命令打包文件夹<br>
<code>zip -r -9 -l -e -q -o [文件名].zip [目录/文件]</code>：用zip命令打包文件夹<br>
<code>-r</code>表示<strong>递归打包包含子目录的全部内容</strong>（打包目录要用<code>-r</code>）<br>
<code>-q</code>表示<strong>静默打包</strong>，不向屏幕输出信息<br>
<code>-o</code>表示输出文件，需要<strong>在后面紧跟打包输出的文件名</strong><br>
<code>-1</code>表示压缩等级：<strong>最快压缩但体积最大</strong><br>
<code>-9</code>表示压缩等级，<strong>体积最小但耗时最久</strong><br>
<code>-e</code>：<strong>创建加密压缩包</strong><br>
<code>-l</code>在linux中<strong>压缩</strong>可以在windows中<strong>解压</strong></p>
<p><code>du -h [压缩文件名].zip</code>查看文件打包后大小</p>
<h3 id="11使用unzip命令解压缩zip文件">1.1使用unzip命令解压缩zip文件</h3>
<p>命令：<br>
<code>unzip [文件名].zip</code>将文件解压到<strong>当前目录</strong><br>
<code>unzip -q [文件名].zip -d [指定目录]</code>将文件<strong>解压到指定目录</strong><br>
<code>unzip -l [文件名].zip</code><strong>不解压文件</strong>，只查看压缩包<strong>内容</strong>。<br>
<code>-l</code>不解压文件直接查看<br>
<strong>注意</strong>：<br>
在linux上打开中文解压包需要使用<code>-O</code>参数指定编码类型。<br>
<code>unzip -O GBK [中文名称文件].zip</code></p>
<h2 id="2tar打包工具">2.tar打包工具</h2>
<p>命令<br>
<code>tar -cf [文件名].tar [目录]</code>不进行压缩只进行打包<br>
<code>-c</code>：创建一个tar包文件<br>
<code>-f</code>：指定创建文件名，文件名必须紧跟在<code>-f</code>参数后</p>
<h3 id="21解包">2.1解包</h3>
<p><code>tar -xf [文件名].tar -C [已存在目录]</code>：解包一个文件到指定路径的<strong>已存在</strong>的目录<br>
<code>-x</code>解包文件参数<br>
<code>-C</code>指定路径参数</p>
<p><code>tar -tf [文件名].tar</code>:只查看不解包文件命令<br>
<code>-t</code>：只查看不解包参数<br>
<code>tar -cphf etc.tar /etc</code>:保留文件属性和跟随链接，有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）</p>
<h3 id="22创建不同的压缩格式文件">2.2创建不同的压缩格式文件</h3>
<p>命令;<br>
<code>tar -czf [文件名].tar.gz [目录/文件]</code>：用tar创建.gz压缩格式的文件。<br>
<code>-z</code>：压缩文件格式：<em>.tar.gz<br>
<code>-J</code>：压缩文件格式：</em>.tar.xz<br>
<code>-j</code>：压缩文件格式：*tar.bz2</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_环境变量]]></title>
        <id>https://ydPro-G.github.io/post/linux_-huan-jing-bian-liang/</id>
        <link href="https://ydPro-G.github.io/post/linux_-huan-jing-bian-liang/">
        </link>
        <updated>2020-03-17T03:35:34.000Z</updated>
        <content type="html"><![CDATA[<p>学习环境变量的作用与用法。</p>
<h1 id="1学习目录">1.学习目录</h1>
<ol>
<li>环境变量</li>
<li>命令的查找路径与顺序</li>
<li>添加自定义路径到PATH环境变量</li>
<li>修改和删除已有的变量</li>
<li>如何让环境变量立即生效</li>
</ol>
<h2 id="1变量">1.变量</h2>
<p>什么是环境变量？<br>
要解释环境变量，得先明白变量是什么，准确是说shell变量，所谓<strong>变量</strong>就是<strong>计算机中用来记录一个值</strong>（可能是数值也可能是字符或者字符串）<strong>的符号</strong>，而<strong>这些符号将用于不同的运算处理中</strong>。通常<strong>变量与值是一对一的关系</strong>，可以<strong>通过表达式读取它的值并赋值给其他变量</strong>，也可以<strong>直接指定数值赋值给任意变量。</strong><br>
为了便于运算和处理，大部分<strong>编程语言会区分变量的类型</strong>，用于分别记录数值，字符，字符串等数据类型。</p>
<h3 id="11创建变量">1.1创建变量</h3>
<p><code>declare [变量]</code>创建变量</p>
<h3 id="12变量赋值">1.2变量赋值</h3>
<p><code>[变量]=[数值]</code>用“=”赋值运算符</p>
<h3 id="13查找变量的值">1.3查找变量的值</h3>
<p><code>echo $[变量]</code></p>
<h2 id="2环境变量">2.环境变量</h2>
<p>环境变量的作用域比自定义变量大，如shell的环境变量作用于他的自身和它的子进程。</p>
<h3 id="21三种变量类型">2.1三种变量类型</h3>
<p>1.当前shell进程私有用户自定义变量，只在当前shell有效。<br>
2.shell本身内建的变量。<br>
3.从自定义变量导出的环境变量。</p>
<h3 id="22打印环境变量的三个命令">2.2打印环境变量的三个命令</h3>
<p><code>set</code>显示当前shell所有变量，包括其内建环境变量，用户自定义变量及导出的环境变量。<br>
<code>env</code>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。<br>
<code>export</code>显示从shell中导出成为环境变量的变量，也能通过他将自定义变量导出为环境变量。<br>
实际案例：<br>
<code>temp[变量名称]=hello[变量设置值]</code>定义一个变量<br>
<code>export temp_env[变量名称]=hello[变量设置值]</code>将自定义变量导出为环境变量<br>
参考：<a href="https://blog.csdn.net/wl_fln/article/details/7258294">linux export命令详解</a></p>
<p>如何将自定义变量设置为环境变量<br>
<img src="https://ydPro-G.github.io//post-images/1584416205608.png" alt="" loading="lazy"></p>
<h3 id="23环境变量永久生效">2.3环境变量永久生效</h3>
<p>按照变量的生存周期来划分，变量分为两种；<br>
1.<br>
<strong>永久</strong>：需要修改配置文件，变量永久生效。<br>
打开<code>/etc/profile</code>添加上想要添加的环境变量，这个环境变量就会变成永久的环境变量。<br>
2.<br>
<strong>临时性的</strong>：使用<code>export</code>命令即可，变量在关闭shell时失效。</p>
<h2 id="3命令的查找路径与顺序">3命令的查找路径与顺序</h2>
<p>简介：我们在shell中输入一个命令，shell怎么知道去哪里找到这个命令并且执行的呢？答案就是这是通过环境变量<code>PATH</code>来进行搜索的。<code>PATH</code>保存了shell中执行的命令的搜索路径。</p>
<h2 id="4添加自定义路径到path环境变量">4.添加自定义路径到PATH环境变量</h2>
<p><code>PATH</code>路径是以<code>：</code>作为分隔符的！<br>
<code>PATH=$PATH:[路径]</code>将自定义的<strong>绝对路径</strong>添加到PATH环境变量中，这样我们就可以在<br>
任意目录下使用这个【自定义路径】的命令了。<br>
但是，这样还<strong>有一个问题，<strong>它</strong>只对当前的shell有效</strong>，我一旦退出终端再打开就就会发现又失效了，有没有一种办法让我们可以让它在全局变量中有效？或者是<strong>让它每次使用的时候自动添加到到PATH中？</strong> 有！</p>
<h3 id="41自动执行">4.1自动执行</h3>
<p>在每个用户的home目录中，有一个shell每次启动时都会默认执行一个配置脚本，用来初始化环境，添加一些用户自定义的环境变量等等。<br>
zsh的配置文件是<code>.zshrc</code><br>
命令：<code>echo &quot;PATH=$PATH:[自定义路径]” &gt;&gt;.zshrc</code><br>
<code>&gt;&gt;</code>表示将标准输出以<strong>追加</strong>的方式重定义到一个文件中<br>
<code>&gt;</code>表示将标准输出以<strong>覆盖</strong>的方式重定义到一个文件中<br>
Bash的配置命令是<code>.bashrc</code><br>
命令：<code>echo ”PATH=$PATH:[自定义路径]&quot; &gt;&gt;.bashrc</code></p>
<h2 id="5修改和删除变量">5.修改和删除变量</h2>
<p>命令<br>
<code>${变量名#匹配字串}</code>从头向后开始匹配，删除符合匹配字串的最短数据<br>
<code>${变量名##匹配字串}</code>从头向后开始匹配，删除符合匹配字串的最长数据<br>
<code>${变量名%匹配字串}</code>从尾向前开始匹配，删除符合匹配字串的最短数据<br>
<code>${变量名%%匹配字串}</code>从尾向前开始匹配，删除符合匹配字串的最长数据<br>
<code>unset</code>删除变量</p>
<h3 id="6让环境变量立即生效">6.让环境变量立即生效</h3>
<p>命令<br>
<code>source [配置的脚本文件]</code>让环境变量立即生效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_搜索命令]]></title>
        <id>https://ydPro-G.github.io/post/linux_-sou-suo-ming-ling/</id>
        <link href="https://ydPro-G.github.io/post/linux_-sou-suo-ming-ling/">
        </link>
        <updated>2020-03-17T03:33:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="常用命令目录">常用命令目录</h1>
<p><code>whereis</code><br>
<code>locat</code><br>
<code>which</code><br>
<code>find</code></p>
<h2 id="whereis-简单快速">whereis 【简单快速】</h2>
<p><code>whereis [文件名]</code>：直接<strong>从数据库中查询</strong>。whereis 只能<strong>搜索二进制文件(-b)</strong>，man <strong>帮助文件(-m)<strong>和</strong>源代码文件(-s)</strong>。</p>
<h2 id="locate-快而全">locate 【快而全】</h2>
<p><code>locate /[目录]/[文件]</code>：用来查找<strong>指定目录</strong>下的<strong>不同文件类型</strong>。<br>
提示;<code>locate</code>通过数据库查找，不过这个数据库也<strong>不是实时更新</strong>的，系统会<strong>使用定时任务每天自动执行 updatedb 命令更新一次</strong>，所以有时候你刚添加的文件，它可能会找不到，需要<strong>手动执行一次 updatedb 命令.</strong><br>
<code>sudo apt-get update</code><br>
<code>sudo apt-get install locate</code><br>
<code>locate /[目录]/[文件]</code></p>
<p>查找<code>/usr/share/</code>下的所有.jpg文件<br>
<code>locate /usr/share/\*.jpg</code><br>
注意：<strong>添加 * 号前面的反斜杠转义</strong></p>
<h2 id="which-小而精">which 【小而精】</h2>
<p><code>which</code>：是 <strong>Shell 内建的一个命令</strong>，我们通常使用 which 来<strong>确定是否安装了某个指定的软件</strong>，因为它<strong>只从 PATH 环境变量指定的路径中去搜索命令。</strong><br>
<code>which [软件]</code></p>
<h2 id="find精而细">find【精而细】</h2>
<p><code>find</code>:可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索.<br>
用法：<code>sudo find [目录] [命令] [文件名]</code></p>
<p>查找<code>/etc/</code>目录下的名字叫做interfaces文件<br>
<code>sudo find /etc/ -name interfaces</code><br>
参数：<br>
<code>-atime</code>：最后访问时间<br>
<code>-ctime</code>:最后修改文件内容的时间<br>
<code>-mtime</code>:最后修改文件属性的时间</p>
<p>列出 home 目录中，当天（24 小时之内）有改动的文件<br>
<code>find ~ -mtime 0</code></p>
<p>列出用户home目录下比 Code 文件夹新的文件<br>
<code>find ~ -newer /home/shiyanlou/Code</code><br>
<code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP协议]]></title>
        <id>https://ydPro-G.github.io/post/tcpip-xie-yi/</id>
        <link href="https://ydPro-G.github.io/post/tcpip-xie-yi/">
        </link>
        <updated>2020-03-17T03:11:04.000Z</updated>
        <content type="html"><![CDATA[<p>1.互联网分成若干层<br>
2.为了实现功能，大家需要遵循相关的规则，这就是协议。</p>
<h2 id="1物理层">1.物理层</h2>
<p>定义：用光缆，电缆，双绞线，无线电波等方式将电脑连起来。<br>
作用：用来传输1,0的电信号。</p>
<h2 id="2链路层">2.链路层</h2>
<p>定义：为了规定解读方式，多少电信号算一组？每个信号位有何意义？<br>
作用：在物理层上面确定0和1的分组方式</p>
<h3 id="21以太网协议">2.1以太网协议</h3>
<p>早期，电信号分组方式每个公司都有，群雄逐鹿，<strong>发展到后来一种叫做“以太网”（Ethernet）的协议占据了主导地位，成为电信号分组方式的规则。</strong></p>
<p><strong>以太网规定</strong>一组电信号组成一个数据包，叫做“帧”（Frame）。每一个帧分为2个部分，标头（Head）和数据（Data）。<br>
<img src="https://ydPro-G.github.io//post-images/1584414725429.png" alt="" loading="lazy"><br>
<strong>标头</strong>包含数据包的一些说明项，比如说发送者，接收者，数据类型之类的等等。<br>
<strong>数据</strong>则是数据包的具体内容。<br>
<strong>标头</strong>的长度固定为18个字节。<br>
<strong>数据</strong>的长度最短为46字节，最长为1500字节。<br>
整个帧最短为64字节，最长为1518字节。</p>
<h3 id="22mac地址">2.2MAC地址</h3>
<p>上面提到，以太网数据包里包含“标头”，里面包含了发送者和接收者的信息。那么发送者和接收者如何标识呢？<br>
以太网协议规定，连入网络的所有设备，都必须具有“网卡”接口。数据包是从一块网卡传送到另一块网卡。网卡的地址就是数据包发送地址和接收地址，这就叫做MAC地址。<br>
<img src="https://ydPro-G.github.io//post-images/1584414800261.png" alt="" loading="lazy"><br>
每块网卡出厂时都有一块独一无二的MAC地址，长度是48个2进制位，通常用12个16进制位来表示。<br>
<img src="https://img-blog.csdnimg.cn/20191120172752148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="网卡地址" loading="lazy"><br>
前6个16进制是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址就能定位网卡和数据包路径。</p>
<h3 id="23广播">2.3广播</h3>
<p>定义地址只是第一位<br>
第一个问题是如何确保一块网卡知道另一块网卡的MAC地址呢？<br>
回答是有一个ARP协议，能够解决这个问题。<br>
第二个问题是即使知道了MAC地址那么如何确保能够把数据包完整准确的发送过去呢？<br>
回答是以太网用了一种很“原始”的方式，它并不是将数据包准确送到接收方，而是将数据包群发出去，由接收者判断是否自己接收。<br>
<img src="https://img-blog.csdnimg.cn/20191120180302381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="示意图" loading="lazy"><br>
上图中①号计算机向②台计算机发送了一个数据包，同一个子网络中的③④⑤也会收到这个包，他们读取这个包的“标头”，找到接收方的MAC地址与自己的MAC地址相比较，如果两者相同就接受这个包，如果不是就丢弃这个包，这种方式就是“广播”（broadcasting）.<br>
有了数据包的定义，网卡的MAC地址，广播的发送方式，“链路层”就可以在多台计算机之间传送数据了。</p>
<h2 id="3网络层">3.网络层</h2>
<p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就能找到洛杉矶的网卡，技术上是可以实现的。<br>
但是，这样做有一个重大缺点，以太网采用广播的方式发送数据包，所有成员人手一“包”，不仅效率低，而且局限在发送者所在的子网络里。<br>
<img src="https://img-blog.csdnimg.cn/20191121151052175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="子网络示意图" loading="lazy"><br>
因此，必须找到一种方法，区分哪些MAC地址属于一个子网络，哪些不是，如果是同一个子网络就采用广播方式发送，如果不是一个子网络就采用路由的方式发送，MAC地址无法做到这一点，它只与厂商有关，与所处网络无关。<br>
这个就是网络层的诞生，它的作用是引进一套新的地址，使我们能够区分不同网络能够属于一个子网络，这套地址就叫做网络地址，简称网址。<br>
于是，在网络层出现后，每台计算机都有2个地址，一个是网络地址，一个是MAC地址，两个地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址是管理员随机组合在一起的。<br>
网络地址帮我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络的中的目标网卡，因此，从逻辑上推荐，必须先处理网络地址，再处理MAC地址。</p>
<h3 id="31-ip协议">3.1 IP协议</h3>
<p>规定网络地址的协议叫做IP协议，它所定义的地址就叫做IP地址。<br>
目前，广泛采用的是IP协议第四版，也就是IPv4.<br>
<strong>IPv4这个协议规定，网络地址由32个二进制位组成：</strong><br>
<img src="https://img-blog.csdnimg.cn/20191121163702341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="IP地址" loading="lazy"><br>
习惯上，我们<strong>用分成4段的十进制数表示IP地址</strong>，从0.0.0.0到255.255.255.255.<br>
互联网上每一个计算机都会分配到一个IP地址。<strong>这个地址分为2部分，前一部分代表网络，后一部分代表主机</strong>。比如IP地址为172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（1），<strong>处在同一个子网络的计算机，它的IP地址的网络部分必然相同</strong>，也就是说172.16.254.2与172.16.254.2是处在同一个子网络里。<br>
但是问题是<strong>单单从IP地址我们无法判断究竟哪些部分是网络地址。</strong><br>
那么，<strong>怎么从IP地址才能判断出两台计算机属于同一个子网络</strong>那？这就<strong>需要用到另一个参数“子网掩码”(subnet mask).</strong><br>
所谓“子网掩码”，就是表示子网络的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，他的网络部分全部为1，主机部分全部为0。比如IP地址为172.16.254.1，它的前24位为网络地址，后八位为主机地址，那么子网掩码就是<br>
11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0.<br>
知道子网掩码，我们就能判断两个IP地址是否属于同一个子网络。方法是将2个IP地址与子网掩码进行AND计算（两个数位都为1，是1，否则为0）然后比较结果是否相同，如果是，就说明他们是在同一个子网络，否则就不是。<br>
<strong>总结一下，IP地址作用主要有2个，一个是为每一台计算机分配IP地址，另一个是确定哪些IP地址属于同一个子网络。</strong></p>
<h3 id="32-ip数据包">3.2 IP数据包</h3>
<p>根据IP地址发送的数据叫做IP数据包，其中包含的数据必然包含IP地址等数据，但是之前说过，以太网数据包只包含MAC地址，并没有IP地址栏位，那么是否修改规则重新添加一个栏位呢？<br>
回答是不需要，我们可以将IP地址放在以太网数据包中的“数据“部分，，这是互联网分层结构的好处：上层的变动完全不涉及下层的结构。<br>
具体来说，IP数据包也分为”标头“”数据“两个部分。<br>
<img src="https://img-blog.csdnimg.cn/20191122152511364.png" alt="ip数据包" loading="lazy"><br>
标头部分主要包含版本，长度，IP地址等信息。“数据”部分则是IP数据包的具体内容。它放进以太网数据包后，数据包变成了这个样。<br>
<img src="https://img-blog.csdnimg.cn/20191122152812496.png" alt="IP地址放进以太网数据包" loading="lazy"><br>
IP数据包的“标头“部分长度为20到60字节，整个数据包的总长度最大为65535字节。因此，理论上，一个IP数据包的&quot;数据”部分最长为65515字节。前面说过，以太网数据包的“数据“部分最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送。</p>
<h3 id="33-arp协议">3.3 ARP协议</h3>
<p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道2个地址，一个是对方的IP地址，一个是对方的MAC地址。通常情况下，对方的IP地址是已知的（？），<strong>但是如何知道对方的MAC地址呢？</strong><br>
所以，我们需要一种机制，能通过IP地址知道MAC地址。<br>
这里又可以分成2种情况：<br>
1）第一种情况，<strong>如果两台计算机没有在一个子网络</strong>，那么事实上没有办法得到对方的MAC地址，<strong>只能把数据传输到两个子网络链接处”网关“（gateway），让网关去处理：</strong><br>
2)第二种情况：<strong>如果2台计算机在同一个子网络</strong>，那么，我们可以用ARP协议，得到对方的MAC地址。<br>
ARP协议<strong>发送数据包</strong>（包含在以太网数据包中）→<strong>包含它所要查询的主机的IP地址，同时在MAC地址填的是FF:FF:FF:FF:FF:FF,表示这是一个“广播”地址</strong>→他所在子网的每一台主机都会收到这个数据包，从中<strong>取出IP地址与自身的IP地址进行比较</strong>→如果两者<strong>相同</strong>，那么就作出<strong>回复</strong>，向对方<strong>报告MAC地址</strong>，否则就丢弃这个包。<br>
总之，有了ARP协议后我们就可以得到同一个子网络的MAC地址了，可以把数据包传送到每一台主机上。</p>
<h2 id="4传输层">4.传输层</h2>
<h3 id="41传输层的由来">4.1传输层的由来</h3>
<p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。<br>
接下来的问题是，同<strong>一台主机上有许多程序都需要用到网络，比如，一边浏览网页，一边在线聊天，当一个数据包从互联网上发过来的时候，你怎么知道，他是表示网页还是表示在线聊天的内容？</strong><br>
也就是说，我们还<strong><strong>需要一个参数，表示这个数据包到底供那个程序（进程）使用，这个参数就叫做”端口“（port）</strong></strong>，它其实是<strong>每一个使用网卡的程序的编号→数据包发送到主机特定端口→不同程序都能取得自己所需要的数据。</strong><br>
<strong>端口</strong>是0到65535之间的一个整数，正好16个二进制位。0—1023端口被系统占用，用户只能选用大于1023的端口使用。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口所联系。<br>
”传输层“的功能就是建立”端口“到”端口“的通信。相比之下，网络层的功能主要是”主机“到”主机“之间的通信，只要确定了主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机和端口叫做”套接字“（socket）。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="42udp协议">4.2UDP协议</h3>
<p>现在我们必须在数据包中添加端口信息，这就需要新的协议，也就是UDP协议。他的格式就是在数据包前面加上端口号。<br>
UDP数据包也包含“标头”和“数据”。<br>
<img src="https://img-blog.csdnimg.cn/20191123174939472.png" alt="UDP" loading="lazy"><br>
标头部分定义：发出端口和接收端口。<br>
数据：包含数据。<br>
然后，把整个UDP协议添加到IP数据包数据部分中，而之前，我们就知道，IP数据包包含在以太网数据包中，所以整个以太网数据包就变成了下面的样子。<br>
<img src="https://img-blog.csdnimg.cn/20191123180818912.png" alt="在这里插入图片描述" loading="lazy"><br>
UDP数据包非常简单，“标头”部分一共8个字节，总长度不超过65，535字节，正好放进一个IP数据包中。</p>
<h3 id="43tcp协议">4.3TCP协议</h3>
<p>UDP协议的优点就是简单，容易实现，缺点是可靠性比较差，一旦数据包发出，无法知道对方是否接收到。为了提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，它是有确认制度的UDP协议，每发出一个数据包都需要确认。<br>
三次握手。<br>
TCP数据包的长度和UDP数据包一样，都是内嵌在IP数据包的“数据”部分，TCP数据包没有长度限制，但是最好还是和IP数据包一样长。</p>
<h2 id="5应用层">5.应用层</h2>
<p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。&quot;应用层&quot;的作用，就是规定应用程序的数据格式。</p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。</p>
<p>因此，现在的以太网的数据包就变成下面这样：<br>
<img src="https://img-blog.csdnimg.cn/20191123183823808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
OVER。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_文件系统]]></title>
        <id>https://ydPro-G.github.io/post/linux_-wen-jian-xi-tong/</id>
        <link href="https://ydPro-G.github.io/post/linux_-wen-jian-xi-tong/">
        </link>
        <updated>2020-03-17T03:01:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习目录">学习目录</h1>
<ol>
<li>新建文件</li>
<li>复制</li>
<li>删除</li>
<li>移动文件与文件重命名</li>
<li>查看文件</li>
<li>查看文件类型</li>
<li>编辑文件</li>
</ol>
<h3 id="1新建文件目录">1.新建文件/目录</h3>
<p>命令：<br>
<code>touch</code>创建空白文件，主要作用更改已有文件时间戳<br>
<code>mkdir</code>新建空目录<br>
<code>mkdir -p</code>新建多级目录，例：<code>mkdir -p father/son/grandson</code></p>
<h3 id="2复制文件目录">2.复制文件/目录</h3>
<p>命令：<br>
<code>cp</code>复制一个文件到指定目录<br>
<code>cp -r</code>复制目录到指定目录，表示递归复制</p>
<h3 id="3删除文件目录">3.删除文件/目录</h3>
<p>命令：<br>
<code>rm</code>删除一个文件<br>
<code>rm -f</code>强制删除<br>
<code>rm -r</code>删除目录 例：<code>rm -r father</code></p>
<h3 id="4移动文件与文件重命名">4.移动文件与文件重命名</h3>
<p>命令：<br>
<code>mv</code>移动文件 例：<code>mv 源目录文件 目的目录</code><br>
<code>mv</code>重命名文件 例：<code>mv 旧的文件名 新的文件名</code><br>
<code>rename</code>批量重命名<br>
例”<code>touch flie{1..5}.txt</code>使用通配符批量创建5个文件<br>
<code>rename 's/\.txt/\.c/ *.txt</code>批量将这5个后缀为.txt的文件重命名为.c为后缀的文件<br>
<code>rename 'y /a-z/A-Z/' *.c</code>批量将这5个文件，文件名和后缀名改为大写</p>
<h3 id="5查看文件">5.查看文件</h3>
<p>命令：<br>
<code>cat</code>查看文件<br>
<code>cat -n</code>查看文件显示行数<br>
<code>nl</code>添加行号并打印<br>
<code>nl -b a</code>表示无论是否为空行，同样列出行数<br>
<code>nl -b t</code>只列出非空行的编号并列出<br>
<code>nl -n ln</code>在行号字段最左端显示<br>
<code>nl -n rn</code>在行号字段最右端显示，切不加0<br>
<code>nl -n rz</code>在行号字段最右端显示，加0<br>
<code>nl -w</code>：行号字段占用的位数（默认6位）<br>
<code>more</code>分页查看文件<br>
<code>head/tail</code>只差看文件头几行（默认10行）<br>
<code>rail -n 1</code>只显示第1行</p>
<h3 id="6查看文件类型">6.查看文件类型</h3>
<p>命令：<br>
<code>file</code>查看文件类型<br>
<code>sudo chown 【用户名]】【文件名】</code>变更文件所有者<br>
命令：<br>
<code>ls</code>显示目标列表（<a href="https://man.linuxde.net/ls">ls具体命令</a>）<br>
<code>ls -l</code>所有输出信息单列格式输出，不输出为多列<br>
<code>ls -AsSh</code>显示所有文件大小 小s显示文件大小，大S显示按文件大小排序</p>
<h2 id="补充关于chmod的用法">补充：关于chmod的用法</h2>
<p>chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。<br>
<strong>1 [001] 执行权限 x<br>
2 [010] 只写权限 w<br>
4 [100] 只读权限 r<br>
若要rwx属性则4+2+1=7；<br>
若要rw-属性则4+2=6；<br>
若要r-x属性则4+1=5。</strong></p>
<p><strong>sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户）</strong></p>
<p><strong>例子：</strong><br>
sudo chmod 600 ××× （只有所有者有读和写的权限）</p>
<p>sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限）</p>
<p>sudo chmod 700 ××× （只有所有者有读和写以及执行的权限）</p>
<p>sudo chmod 666 ××× （每个人都有读和写的权限）</p>
<p>sudo chmod 777 ××× （每个人都有读和写以及执行的权限）</p>
<h2 id="图示">图示：</h2>
<p><img src="https://ydPro-G.github.io//post-images/1583994819019.jpg" alt="" loading="lazy"><br>
<img src="https://ydPro-G.github.io//post-images/1583994825917.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux_目录路径]]></title>
        <id>https://ydPro-G.github.io/post/linux_-mu-lu-lu-jing/</id>
        <link href="https://ydPro-G.github.io/post/linux_-mu-lu-lu-jing/">
        </link>
        <updated>2020-03-17T02:53:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="学习目录">学习目录</h2>
<ol>
<li>路径</li>
<li>绝对路径</li>
<li>相对路径</li>
</ol>
<h3 id="1路径进入目录的路径">1.路径：进入目录的路径</h3>
<p>命令：<br>
<code>cd ..</code>：进入上一级目录<br>
<code>cd ~</code>：进入你的home目录<br>
<code>cd /home/你的用户名</code>：进入你的home目录<br>
<code>pwd</code>：获取当前路径</p>
<h3 id="2绝对路径">2.绝对路径</h3>
<p>命令：<br>
<code>cd 用户/用户名/系统文件</code>：绝对路径是指文件在硬盘上真正存在的路径。<br>
事实上，在网页编程时，很少会使用绝对路径，如果使用“E:\book\网页布\代码\第2章\bg.jpg”来指定背景图片的位置，在自己的计算机上 浏览可能会一切正常，但是上传到Web服务器上浏览就很有可能不会显示图片了。<br>
因为上传到Web服务器上时，可能整个网站并没有放在Web服务器的E盘， 有可能是D盘或H盘。即使放在Web服务器的E盘里，Web服务器的E盘里也不一定会存在“E:\book\网页布局\代码\第2章”这个目录，因此在浏 览网页时是不会显示图片的。</p>
<h3 id="3相对路径">3.相对路径</h3>
<p>命令：<br>
<code>cd ../../用户/用户名/系统文件</code>：为了避免这种隋况发生，通常在网页里指定文件时，都会选择使用相对路径。<br>
所谓相对路径，就是相对于自己的目标文件位置。<br>
例如上面的例子，“s1.htm” 文件里引用了“bg.jpg”图片，由于“bg.jpg”图片相对于“s1.htm”来说，是在同一个目录的，那么要在“s1.htm”文件里使用以下代 码后，只要这两个文件的相对位置没有变(也就是说还是在同一个目录内)，那么无论上传到Web服务器的哪个位置，在浏览器里都能正确地显示图片。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[My Blogs]]></title>
        <id>https://ydPro-G.github.io/post/friends/</id>
        <link href="https://ydPro-G.github.io/post/friends/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>记录学习 &amp; 编程 &amp; 黑科技&amp;有趣&amp;好玩🕶</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>致力于学习技术 &amp; 提高收入的社畜😇</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>读书，编程，跑步，做视频，睡觉🙌</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>15806906223@163.com📧</p>
]]></content>
    </entry>
</feed>