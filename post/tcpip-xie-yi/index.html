<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ydPro Blog</title>
<meta name="description" content="Life & Work" />
<link rel="shortcut icon" href="https://ydPro-G.github.io//favicon.ico?v=1584418852003">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://ydPro-G.github.io//styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://ydPro-G.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://ydPro-G.github.io//images/avatar.png?v=1584418852003" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">ydPro Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E7%89%A9%E7%90%86%E5%B1%82">1.物理层</a></li>
<li><a href="#2%E9%93%BE%E8%B7%AF%E5%B1%82">2.链路层</a>
<ul>
<li><a href="#21%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE">2.1以太网协议</a></li>
<li><a href="#22mac%E5%9C%B0%E5%9D%80">2.2MAC地址</a></li>
<li><a href="#23%E5%B9%BF%E6%92%AD">2.3广播</a></li>
</ul>
</li>
<li><a href="#3%E7%BD%91%E7%BB%9C%E5%B1%82">3.网络层</a>
<ul>
<li><a href="#31-ip%E5%8D%8F%E8%AE%AE">3.1 IP协议</a></li>
<li><a href="#32-ip%E6%95%B0%E6%8D%AE%E5%8C%85">3.2 IP数据包</a></li>
<li><a href="#33-arp%E5%8D%8F%E8%AE%AE">3.3 ARP协议</a></li>
</ul>
</li>
<li><a href="#4%E4%BC%A0%E8%BE%93%E5%B1%82">4.传输层</a>
<ul>
<li><a href="#41%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E7%94%B1%E6%9D%A5">4.1传输层的由来</a></li>
<li><a href="#42udp%E5%8D%8F%E8%AE%AE">4.2UDP协议</a></li>
<li><a href="#43tcp%E5%8D%8F%E8%AE%AE">4.3TCP协议</a></li>
</ul>
</li>
<li><a href="#5%E5%BA%94%E7%94%A8%E5%B1%82">5.应用层</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.2s">
          标签
        </a>
      
    
      
        <a href="https://ydPro-G.github.io/post/friends" class="menu" style="animation-delay: 0.4s">
          关于我
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://ydPro-G.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">TCP/IP协议</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-17 / 12 min read
        </div>
        
        <div class="post-content yue">
          <p>1.互联网分成若干层<br>
2.为了实现功能，大家需要遵循相关的规则，这就是协议。</p>
<h2 id="1物理层">1.物理层</h2>
<p>定义：用光缆，电缆，双绞线，无线电波等方式将电脑连起来。<br>
作用：用来传输1,0的电信号。</p>
<h2 id="2链路层">2.链路层</h2>
<p>定义：为了规定解读方式，多少电信号算一组？每个信号位有何意义？<br>
作用：在物理层上面确定0和1的分组方式</p>
<h3 id="21以太网协议">2.1以太网协议</h3>
<p>早期，电信号分组方式每个公司都有，群雄逐鹿，<strong>发展到后来一种叫做“以太网”（Ethernet）的协议占据了主导地位，成为电信号分组方式的规则。</strong></p>
<p><strong>以太网规定</strong>一组电信号组成一个数据包，叫做“帧”（Frame）。每一个帧分为2个部分，标头（Head）和数据（Data）。<br>
<img src="https://ydPro-G.github.io//post-images/1584414725429.png" alt="" loading="lazy"><br>
<strong>标头</strong>包含数据包的一些说明项，比如说发送者，接收者，数据类型之类的等等。<br>
<strong>数据</strong>则是数据包的具体内容。<br>
<strong>标头</strong>的长度固定为18个字节。<br>
<strong>数据</strong>的长度最短为46字节，最长为1500字节。<br>
整个帧最短为64字节，最长为1518字节。</p>
<h3 id="22mac地址">2.2MAC地址</h3>
<p>上面提到，以太网数据包里包含“标头”，里面包含了发送者和接收者的信息。那么发送者和接收者如何标识呢？<br>
以太网协议规定，连入网络的所有设备，都必须具有“网卡”接口。数据包是从一块网卡传送到另一块网卡。网卡的地址就是数据包发送地址和接收地址，这就叫做MAC地址。<br>
<img src="https://ydPro-G.github.io//post-images/1584414800261.png" alt="" loading="lazy"><br>
每块网卡出厂时都有一块独一无二的MAC地址，长度是48个2进制位，通常用12个16进制位来表示。<br>
<img src="https://img-blog.csdnimg.cn/20191120172752148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="网卡地址" loading="lazy"><br>
前6个16进制是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址就能定位网卡和数据包路径。</p>
<h3 id="23广播">2.3广播</h3>
<p>定义地址只是第一位<br>
第一个问题是如何确保一块网卡知道另一块网卡的MAC地址呢？<br>
回答是有一个ARP协议，能够解决这个问题。<br>
第二个问题是即使知道了MAC地址那么如何确保能够把数据包完整准确的发送过去呢？<br>
回答是以太网用了一种很“原始”的方式，它并不是将数据包准确送到接收方，而是将数据包群发出去，由接收者判断是否自己接收。<br>
<img src="https://img-blog.csdnimg.cn/20191120180302381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="示意图" loading="lazy"><br>
上图中①号计算机向②台计算机发送了一个数据包，同一个子网络中的③④⑤也会收到这个包，他们读取这个包的“标头”，找到接收方的MAC地址与自己的MAC地址相比较，如果两者相同就接受这个包，如果不是就丢弃这个包，这种方式就是“广播”（broadcasting）.<br>
有了数据包的定义，网卡的MAC地址，广播的发送方式，“链路层”就可以在多台计算机之间传送数据了。</p>
<h2 id="3网络层">3.网络层</h2>
<p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就能找到洛杉矶的网卡，技术上是可以实现的。<br>
但是，这样做有一个重大缺点，以太网采用广播的方式发送数据包，所有成员人手一“包”，不仅效率低，而且局限在发送者所在的子网络里。<br>
<img src="https://img-blog.csdnimg.cn/20191121151052175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="子网络示意图" loading="lazy"><br>
因此，必须找到一种方法，区分哪些MAC地址属于一个子网络，哪些不是，如果是同一个子网络就采用广播方式发送，如果不是一个子网络就采用路由的方式发送，MAC地址无法做到这一点，它只与厂商有关，与所处网络无关。<br>
这个就是网络层的诞生，它的作用是引进一套新的地址，使我们能够区分不同网络能够属于一个子网络，这套地址就叫做网络地址，简称网址。<br>
于是，在网络层出现后，每台计算机都有2个地址，一个是网络地址，一个是MAC地址，两个地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址是管理员随机组合在一起的。<br>
网络地址帮我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络的中的目标网卡，因此，从逻辑上推荐，必须先处理网络地址，再处理MAC地址。</p>
<h3 id="31-ip协议">3.1 IP协议</h3>
<p>规定网络地址的协议叫做IP协议，它所定义的地址就叫做IP地址。<br>
目前，广泛采用的是IP协议第四版，也就是IPv4.<br>
<strong>IPv4这个协议规定，网络地址由32个二进制位组成：</strong><br>
<img src="https://img-blog.csdnimg.cn/20191121163702341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="IP地址" loading="lazy"><br>
习惯上，我们<strong>用分成4段的十进制数表示IP地址</strong>，从0.0.0.0到255.255.255.255.<br>
互联网上每一个计算机都会分配到一个IP地址。<strong>这个地址分为2部分，前一部分代表网络，后一部分代表主机</strong>。比如IP地址为172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（1），<strong>处在同一个子网络的计算机，它的IP地址的网络部分必然相同</strong>，也就是说172.16.254.2与172.16.254.2是处在同一个子网络里。<br>
但是问题是<strong>单单从IP地址我们无法判断究竟哪些部分是网络地址。</strong><br>
那么，<strong>怎么从IP地址才能判断出两台计算机属于同一个子网络</strong>那？这就<strong>需要用到另一个参数“子网掩码”(subnet mask).</strong><br>
所谓“子网掩码”，就是表示子网络的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，他的网络部分全部为1，主机部分全部为0。比如IP地址为172.16.254.1，它的前24位为网络地址，后八位为主机地址，那么子网掩码就是<br>
11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0.<br>
知道子网掩码，我们就能判断两个IP地址是否属于同一个子网络。方法是将2个IP地址与子网掩码进行AND计算（两个数位都为1，是1，否则为0）然后比较结果是否相同，如果是，就说明他们是在同一个子网络，否则就不是。<br>
<strong>总结一下，IP地址作用主要有2个，一个是为每一台计算机分配IP地址，另一个是确定哪些IP地址属于同一个子网络。</strong></p>
<h3 id="32-ip数据包">3.2 IP数据包</h3>
<p>根据IP地址发送的数据叫做IP数据包，其中包含的数据必然包含IP地址等数据，但是之前说过，以太网数据包只包含MAC地址，并没有IP地址栏位，那么是否修改规则重新添加一个栏位呢？<br>
回答是不需要，我们可以将IP地址放在以太网数据包中的“数据“部分，，这是互联网分层结构的好处：上层的变动完全不涉及下层的结构。<br>
具体来说，IP数据包也分为”标头“”数据“两个部分。<br>
<img src="https://img-blog.csdnimg.cn/20191122152511364.png" alt="ip数据包" loading="lazy"><br>
标头部分主要包含版本，长度，IP地址等信息。“数据”部分则是IP数据包的具体内容。它放进以太网数据包后，数据包变成了这个样。<br>
<img src="https://img-blog.csdnimg.cn/20191122152812496.png" alt="IP地址放进以太网数据包" loading="lazy"><br>
IP数据包的“标头“部分长度为20到60字节，整个数据包的总长度最大为65535字节。因此，理论上，一个IP数据包的&quot;数据”部分最长为65515字节。前面说过，以太网数据包的“数据“部分最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送。</p>
<h3 id="33-arp协议">3.3 ARP协议</h3>
<p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道2个地址，一个是对方的IP地址，一个是对方的MAC地址。通常情况下，对方的IP地址是已知的（？），<strong>但是如何知道对方的MAC地址呢？</strong><br>
所以，我们需要一种机制，能通过IP地址知道MAC地址。<br>
这里又可以分成2种情况：<br>
1）第一种情况，<strong>如果两台计算机没有在一个子网络</strong>，那么事实上没有办法得到对方的MAC地址，<strong>只能把数据传输到两个子网络链接处”网关“（gateway），让网关去处理：</strong><br>
2)第二种情况：<strong>如果2台计算机在同一个子网络</strong>，那么，我们可以用ARP协议，得到对方的MAC地址。<br>
ARP协议<strong>发送数据包</strong>（包含在以太网数据包中）→<strong>包含它所要查询的主机的IP地址，同时在MAC地址填的是FF:FF:FF:FF:FF:FF,表示这是一个“广播”地址</strong>→他所在子网的每一台主机都会收到这个数据包，从中<strong>取出IP地址与自身的IP地址进行比较</strong>→如果两者<strong>相同</strong>，那么就作出<strong>回复</strong>，向对方<strong>报告MAC地址</strong>，否则就丢弃这个包。<br>
总之，有了ARP协议后我们就可以得到同一个子网络的MAC地址了，可以把数据包传送到每一台主机上。</p>
<h2 id="4传输层">4.传输层</h2>
<h3 id="41传输层的由来">4.1传输层的由来</h3>
<p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。<br>
接下来的问题是，同<strong>一台主机上有许多程序都需要用到网络，比如，一边浏览网页，一边在线聊天，当一个数据包从互联网上发过来的时候，你怎么知道，他是表示网页还是表示在线聊天的内容？</strong><br>
也就是说，我们还<strong><strong>需要一个参数，表示这个数据包到底供那个程序（进程）使用，这个参数就叫做”端口“（port）</strong></strong>，它其实是<strong>每一个使用网卡的程序的编号→数据包发送到主机特定端口→不同程序都能取得自己所需要的数据。</strong><br>
<strong>端口</strong>是0到65535之间的一个整数，正好16个二进制位。0—1023端口被系统占用，用户只能选用大于1023的端口使用。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口所联系。<br>
”传输层“的功能就是建立”端口“到”端口“的通信。相比之下，网络层的功能主要是”主机“到”主机“之间的通信，只要确定了主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机和端口叫做”套接字“（socket）。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="42udp协议">4.2UDP协议</h3>
<p>现在我们必须在数据包中添加端口信息，这就需要新的协议，也就是UDP协议。他的格式就是在数据包前面加上端口号。<br>
UDP数据包也包含“标头”和“数据”。<br>
<img src="https://img-blog.csdnimg.cn/20191123174939472.png" alt="UDP" loading="lazy"><br>
标头部分定义：发出端口和接收端口。<br>
数据：包含数据。<br>
然后，把整个UDP协议添加到IP数据包数据部分中，而之前，我们就知道，IP数据包包含在以太网数据包中，所以整个以太网数据包就变成了下面的样子。<br>
<img src="https://img-blog.csdnimg.cn/20191123180818912.png" alt="在这里插入图片描述" loading="lazy"><br>
UDP数据包非常简单，“标头”部分一共8个字节，总长度不超过65，535字节，正好放进一个IP数据包中。</p>
<h3 id="43tcp协议">4.3TCP协议</h3>
<p>UDP协议的优点就是简单，容易实现，缺点是可靠性比较差，一旦数据包发出，无法知道对方是否接收到。为了提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，它是有确认制度的UDP协议，每发出一个数据包都需要确认。<br>
三次握手。<br>
TCP数据包的长度和UDP数据包一样，都是内嵌在IP数据包的“数据”部分，TCP数据包没有长度限制，但是最好还是和IP数据包一样长。</p>
<h2 id="5应用层">5.应用层</h2>
<p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。&quot;应用层&quot;的作用，就是规定应用程序的数据格式。</p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。</p>
<p>因此，现在的以太网的数据包就变成下面这样：<br>
<img src="https://img-blog.csdnimg.cn/20191123183823808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lkUHJvXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
OVER。</p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://ydPro-G.github.io/tag/G-9rlSimO/">
            <span class="flex-auto">TCP/IP</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://ydPro-G.github.io/post/linux_-sou-suo-ming-ling/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  Linux_搜索命令
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://ydPro-G.github.io/post/linux_-wen-jian-xi-tong/">
                <h3 class="post-title">
                  Linux_文件系统
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://ydPro-G.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
